Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> translation_unit
Rule 1     translation_unit -> <empty>
Rule 2     translation_unit -> external_declaration
Rule 3     translation_unit -> translation_unit external_declaration
Rule 4     external_declaration -> semicolons
Rule 5     external_declaration -> vars_declaration semicolons
Rule 6     external_declaration -> function_definition
Rule 7     statement_list -> <empty>
Rule 8     statement_list -> statement_list statement
Rule 9     statement -> simple_statement
Rule 10    statement -> block
Rule 11    statement -> selection_statement
Rule 12    statement -> iteration_statement
Rule 13    statement -> jump_statement
Rule 14    simple_statement -> semicolons
Rule 15    simple_statement -> expression semicolons
Rule 16    block -> LBRACE statement_list RBRACE
Rule 17    selection_statement -> if
Rule 18    jump_statement -> return
Rule 19    jump_statement -> continue
Rule 20    jump_statement -> break
Rule 21    return -> RETURN
Rule 22    return -> RETURN logical_expression
Rule 23    continue -> CONTINUE
Rule 24    break -> BREAK
Rule 25    iteration_statement -> for
Rule 26    iteration_statement -> while
Rule 27    iteration_statement -> dowhile
Rule 28    expression -> logical_expression
Rule 29    expression -> assignment
Rule 30    expression -> vars_declaration
Rule 31    expression_list -> <empty>
Rule 32    expression_list -> expression
Rule 33    expression_list -> expression_list COMMA expression
Rule 34    logical_expression -> logical_or_expression
Rule 35    logical_or_expression -> logical_and_expression
Rule 36    logical_or_expression -> logical_or_expression OR logical_and_expression
Rule 37    logical_and_expression -> equality_expression
Rule 38    logical_and_expression -> logical_and_expression AND equality_expression
Rule 39    equality_expression -> relational_expression
Rule 40    equality_expression -> equality_expression EQUALS relational_expression
Rule 41    equality_expression -> equality_expression NOTEQUALS relational_expression
Rule 42    relational_expression -> additive_expression
Rule 43    relational_expression -> relational_expression GT additive_expression
Rule 44    relational_expression -> relational_expression LT additive_expression
Rule 45    relational_expression -> relational_expression GE additive_expression
Rule 46    relational_expression -> relational_expression LE additive_expression
Rule 47    additive_expression -> multiplicative_expression
Rule 48    additive_expression -> additive_expression ADD multiplicative_expression
Rule 49    additive_expression -> additive_expression SUB multiplicative_expression
Rule 50    multiplicative_expression -> unary_expression
Rule 51    multiplicative_expression -> multiplicative_expression MUL unary_expression
Rule 52    multiplicative_expression -> multiplicative_expression DIV unary_expression
Rule 53    multiplicative_expression -> multiplicative_expression MOD unary_expression
Rule 54    unary_expression -> postfix_expression
Rule 55    unary_expression -> NOT group
Rule 56    unary_expression -> SUB group
Rule 57    unary_expression -> ADD group
Rule 58    postfix_expression -> group
Rule 59    postfix_expression -> lvalue INC_OP
Rule 60    postfix_expression -> lvalue DEC_OP
Rule 61    group -> call
Rule 62    group -> lvalue
Rule 63    group -> LPAREN logical_expression RPAREN
Rule 64    group -> number
Rule 65    group -> string
Rule 66    group -> bool_value
Rule 67    if -> IF LPAREN logical_expression RPAREN statement
Rule 68    if -> IF LPAREN logical_expression RPAREN statement ELSE statement
Rule 69    assignment -> lvalue assignment_operation rvalue
Rule 70    rvalue -> logical_expression
Rule 71    rvalue -> array_value
Rule 72    rvalue -> lvalue assignment_operation rvalue
Rule 73    assignment_operation -> ASSIGN
Rule 74    assignment_operation -> ADD_ASSIGN
Rule 75    assignment_operation -> SUB_ASSIGN
Rule 76    assignment_operation -> MUL_ASSIGN
Rule 77    assignment_operation -> DIV_ASSIGN
Rule 78    assignment_operation -> MOD_ASSIGN
Rule 79    simple_rvalue -> logical_expression
Rule 80    simple_rvalue -> lvalue ASSIGN simple_rvalue
Rule 81    string -> STRING
Rule 82    call -> ident LPAREN args_list RPAREN
Rule 83    function_definition -> type ident LPAREN arguments_declaration_list RPAREN block
Rule 84    arguments_declaration_list -> <empty>
Rule 85    arguments_declaration_list -> argument_declaration
Rule 86    arguments_declaration_list -> arguments_declaration_list COMMA argument_declaration
Rule 87    argument_declaration -> type ident
Rule 88    args_list -> <empty>
Rule 89    args_list -> logical_expression
Rule 90    args_list -> args_list COMMA logical_expression
Rule 91    vars_declaration -> type init_declarator_list
Rule 92    vars_declaration -> type_array init_array_declarator_list
Rule 93    ident -> IDENT
Rule 94    type_array -> IDENT BRACKETS
Rule 95    type -> IDENT
Rule 96    init_declarator_list -> init_declarator
Rule 97    init_declarator_list -> init_declarator_list COMMA init_declarator
Rule 98    init_array_declarator_list -> init_array_declarator
Rule 99    init_array_declarator_list -> init_array_declarator_list COMMA init_array_declarator
Rule 100   init_declarator -> ident
Rule 101   init_declarator -> ident_initializer
Rule 102   init_array_declarator -> array_ident
Rule 103   init_array_declarator -> array_initializer
Rule 104   ident_initializer -> ident ASSIGN simple_rvalue
Rule 105   array_initializer -> ident ASSIGN array_value
Rule 106   array_value -> NEW type LBRACKET logical_expression RBRACKET
Rule 107   array_value -> NEW type BRACKETS LBRACE args_list RBRACE
Rule 108   array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE
Rule 109   array_ident -> ident
Rule 110   lvalue -> ident
Rule 111   lvalue -> get_element
Rule 112   get_element -> ident LBRACKET logical_expression RBRACKET
Rule 113   for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
Rule 114   for_condition -> <empty>
Rule 115   for_condition -> logical_expression
Rule 116   dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons
Rule 117   while -> WHILE LPAREN logical_expression RPAREN statement
Rule 118   bool_value -> TRUE
Rule 119   bool_value -> FALSE
Rule 120   number -> NUMBER
Rule 121   semicolons -> SEMICOLON
Rule 122   semicolons -> semicolons SEMICOLON

Terminals, with rules where they appear

ADD                  : 48 57
ADD_ASSIGN           : 74
AND                  : 38
ASSIGN               : 73 80 104 105
BRACKETS             : 94 107
BREAK                : 24
COMMA                : 33 86 90 97 99
CONTINUE             : 23
DEC_OP               : 60
DIV                  : 52
DIV_ASSIGN           : 77
DO                   : 116
ELSE                 : 68
EQUALS               : 40
FALSE                : 119
FOR                  : 113
GE                   : 45
GT                   : 43
IDENT                : 93 94 95
IF                   : 67 68
INC_OP               : 59
LBRACE               : 16 107 108
LBRACKET             : 106 108 112
LE                   : 46
LPAREN               : 63 67 68 82 83 113 116 117
LT                   : 44
MOD                  : 53
MOD_ASSIGN           : 78
MUL                  : 51
MUL_ASSIGN           : 76
NEW                  : 106 107 108
NOT                  : 55
NOTEQUALS            : 41
NUMBER               : 120
OR                   : 36
RBRACE               : 16 107 108
RBRACKET             : 106 108 112
RETURN               : 21 22
RPAREN               : 63 67 68 82 83 113 116 117
SEMICOLON            : 113 113 121 122
STRING               : 81
SUB                  : 49 56
SUB_ASSIGN           : 75
TRUE                 : 118
WHILE                : 116 117
error                : 

Nonterminals, with rules where they appear

additive_expression  : 42 43 44 45 46 48 49
args_list            : 82 90 107 108
argument_declaration : 85 86
arguments_declaration_list : 83 86
array_ident          : 102
array_initializer    : 103
array_value          : 71 105
assignment           : 29
assignment_operation : 69 72
block                : 10 83
bool_value           : 66
break                : 20
call                 : 61
continue             : 19
dowhile              : 27
equality_expression  : 37 38 40 41
expression           : 15 32 33
expression_list      : 33 113 113
external_declaration : 2 3
for                  : 25
for_condition        : 113
function_definition  : 6
get_element          : 111
group                : 55 56 57 58
ident                : 82 83 87 100 104 105 109 110 112
ident_initializer    : 101
if                   : 17
init_array_declarator : 98 99
init_array_declarator_list : 92 99
init_declarator      : 96 97
init_declarator_list : 91 97
iteration_statement  : 12
jump_statement       : 13
logical_and_expression : 35 36 38
logical_expression   : 22 28 63 67 68 70 79 89 90 106 108 112 115 116 117
logical_or_expression : 34 36
lvalue               : 59 60 62 69 72 80
multiplicative_expression : 47 48 49 51 52 53
number               : 64
postfix_expression   : 54
relational_expression : 39 40 41 43 44 45 46
return               : 18
rvalue               : 69 72
selection_statement  : 11
semicolons           : 4 5 14 15 116 122
simple_rvalue        : 80 104
simple_statement     : 9
statement            : 8 67 68 68 113 116 117
statement_list       : 8 16
string               : 65
translation_unit     : 3 0
type                 : 83 87 91 106 107 108
type_array           : 92
unary_expression     : 50 51 52 53
vars_declaration     : 5 30
while                : 26

Parsing method: LALR

state 0

    (0) S' -> . translation_unit
    (1) translation_unit -> .
    (2) translation_unit -> . external_declaration
    (3) translation_unit -> . translation_unit external_declaration
    (4) external_declaration -> . semicolons
    (5) external_declaration -> . vars_declaration semicolons
    (6) external_declaration -> . function_definition
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (83) function_definition -> . type ident LPAREN arguments_declaration_list RPAREN block
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
    $end            reduce using rule 1 (translation_unit -> .)
    SEMICOLON       shift and go to state 6
    IDENT           shift and go to state 9

  ! SEMICOLON       [ reduce using rule 1 (translation_unit -> .) ]
  ! IDENT           [ reduce using rule 1 (translation_unit -> .) ]

    translation_unit               shift and go to state 1
    external_declaration           shift and go to state 2
    semicolons                     shift and go to state 3
    vars_declaration               shift and go to state 4
    function_definition            shift and go to state 5
    type                           shift and go to state 7
    type_array                     shift and go to state 8

state 1

    (0) S' -> translation_unit .
    (3) translation_unit -> translation_unit . external_declaration
    (4) external_declaration -> . semicolons
    (5) external_declaration -> . vars_declaration semicolons
    (6) external_declaration -> . function_definition
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (83) function_definition -> . type ident LPAREN arguments_declaration_list RPAREN block
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS

    SEMICOLON       shift and go to state 6
    IDENT           shift and go to state 9

    external_declaration           shift and go to state 10
    semicolons                     shift and go to state 3
    vars_declaration               shift and go to state 4
    function_definition            shift and go to state 5
    type                           shift and go to state 7
    type_array                     shift and go to state 8

state 2

    (2) translation_unit -> external_declaration .

    SEMICOLON       reduce using rule 2 (translation_unit -> external_declaration .)
    IDENT           reduce using rule 2 (translation_unit -> external_declaration .)
    $end            reduce using rule 2 (translation_unit -> external_declaration .)


state 3

    (4) external_declaration -> semicolons .
    (122) semicolons -> semicolons . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IDENT           reduce using rule 4 (external_declaration -> semicolons .)
    $end            reduce using rule 4 (external_declaration -> semicolons .)
    SEMICOLON       shift and go to state 11

  ! SEMICOLON       [ reduce using rule 4 (external_declaration -> semicolons .) ]


state 4

    (5) external_declaration -> vars_declaration . semicolons
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON

    SEMICOLON       shift and go to state 6

    semicolons                     shift and go to state 12

state 5

    (6) external_declaration -> function_definition .

    SEMICOLON       reduce using rule 6 (external_declaration -> function_definition .)
    IDENT           reduce using rule 6 (external_declaration -> function_definition .)
    $end            reduce using rule 6 (external_declaration -> function_definition .)


state 6

    (121) semicolons -> SEMICOLON .

    SEMICOLON       reduce using rule 121 (semicolons -> SEMICOLON .)
    IDENT           reduce using rule 121 (semicolons -> SEMICOLON .)
    $end            reduce using rule 121 (semicolons -> SEMICOLON .)
    RBRACE          reduce using rule 121 (semicolons -> SEMICOLON .)
    LBRACE          reduce using rule 121 (semicolons -> SEMICOLON .)
    IF              reduce using rule 121 (semicolons -> SEMICOLON .)
    FOR             reduce using rule 121 (semicolons -> SEMICOLON .)
    WHILE           reduce using rule 121 (semicolons -> SEMICOLON .)
    DO              reduce using rule 121 (semicolons -> SEMICOLON .)
    RETURN          reduce using rule 121 (semicolons -> SEMICOLON .)
    CONTINUE        reduce using rule 121 (semicolons -> SEMICOLON .)
    BREAK           reduce using rule 121 (semicolons -> SEMICOLON .)
    NOT             reduce using rule 121 (semicolons -> SEMICOLON .)
    SUB             reduce using rule 121 (semicolons -> SEMICOLON .)
    ADD             reduce using rule 121 (semicolons -> SEMICOLON .)
    LPAREN          reduce using rule 121 (semicolons -> SEMICOLON .)
    NUMBER          reduce using rule 121 (semicolons -> SEMICOLON .)
    STRING          reduce using rule 121 (semicolons -> SEMICOLON .)
    TRUE            reduce using rule 121 (semicolons -> SEMICOLON .)
    FALSE           reduce using rule 121 (semicolons -> SEMICOLON .)
    ELSE            reduce using rule 121 (semicolons -> SEMICOLON .)


state 7

    (91) vars_declaration -> type . init_declarator_list
    (83) function_definition -> type . ident LPAREN arguments_declaration_list RPAREN block
    (96) init_declarator_list -> . init_declarator
    (97) init_declarator_list -> . init_declarator_list COMMA init_declarator
    (93) ident -> . IDENT
    (100) init_declarator -> . ident
    (101) init_declarator -> . ident_initializer
    (104) ident_initializer -> . ident ASSIGN simple_rvalue

    IDENT           shift and go to state 16

    init_declarator_list           shift and go to state 13
    ident                          shift and go to state 14
    init_declarator                shift and go to state 15
    ident_initializer              shift and go to state 17

state 8

    (92) vars_declaration -> type_array . init_array_declarator_list
    (98) init_array_declarator_list -> . init_array_declarator
    (99) init_array_declarator_list -> . init_array_declarator_list COMMA init_array_declarator
    (102) init_array_declarator -> . array_ident
    (103) init_array_declarator -> . array_initializer
    (109) array_ident -> . ident
    (105) array_initializer -> . ident ASSIGN array_value
    (93) ident -> . IDENT

    IDENT           shift and go to state 16

    init_array_declarator_list     shift and go to state 18
    init_array_declarator          shift and go to state 19
    array_ident                    shift and go to state 20
    array_initializer              shift and go to state 21
    ident                          shift and go to state 22

state 9

    (95) type -> IDENT .
    (94) type_array -> IDENT . BRACKETS

    IDENT           reduce using rule 95 (type -> IDENT .)
    BRACKETS        shift and go to state 23


state 10

    (3) translation_unit -> translation_unit external_declaration .

    SEMICOLON       reduce using rule 3 (translation_unit -> translation_unit external_declaration .)
    IDENT           reduce using rule 3 (translation_unit -> translation_unit external_declaration .)
    $end            reduce using rule 3 (translation_unit -> translation_unit external_declaration .)


state 11

    (122) semicolons -> semicolons SEMICOLON .

    SEMICOLON       reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    IDENT           reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    $end            reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    RBRACE          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    LBRACE          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    IF              reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    FOR             reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    WHILE           reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    DO              reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    RETURN          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    CONTINUE        reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    BREAK           reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    NOT             reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    SUB             reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    ADD             reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    LPAREN          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    NUMBER          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    STRING          reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    TRUE            reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    FALSE           reduce using rule 122 (semicolons -> semicolons SEMICOLON .)
    ELSE            reduce using rule 122 (semicolons -> semicolons SEMICOLON .)


state 12

    (5) external_declaration -> vars_declaration semicolons .
    (122) semicolons -> semicolons . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    IDENT           reduce using rule 5 (external_declaration -> vars_declaration semicolons .)
    $end            reduce using rule 5 (external_declaration -> vars_declaration semicolons .)
    SEMICOLON       shift and go to state 11

  ! SEMICOLON       [ reduce using rule 5 (external_declaration -> vars_declaration semicolons .) ]


state 13

    (91) vars_declaration -> type init_declarator_list .
    (97) init_declarator_list -> init_declarator_list . COMMA init_declarator

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 91 (vars_declaration -> type init_declarator_list .)
    RPAREN          reduce using rule 91 (vars_declaration -> type init_declarator_list .)
    COMMA           shift and go to state 24

  ! COMMA           [ reduce using rule 91 (vars_declaration -> type init_declarator_list .) ]


state 14

    (83) function_definition -> type ident . LPAREN arguments_declaration_list RPAREN block
    (100) init_declarator -> ident .
    (104) ident_initializer -> ident . ASSIGN simple_rvalue

    LPAREN          shift and go to state 25
    COMMA           reduce using rule 100 (init_declarator -> ident .)
    SEMICOLON       reduce using rule 100 (init_declarator -> ident .)
    ASSIGN          shift and go to state 26


state 15

    (96) init_declarator_list -> init_declarator .

    COMMA           reduce using rule 96 (init_declarator_list -> init_declarator .)
    SEMICOLON       reduce using rule 96 (init_declarator_list -> init_declarator .)
    RPAREN          reduce using rule 96 (init_declarator_list -> init_declarator .)


state 16

    (93) ident -> IDENT .

    LPAREN          reduce using rule 93 (ident -> IDENT .)
    ASSIGN          reduce using rule 93 (ident -> IDENT .)
    COMMA           reduce using rule 93 (ident -> IDENT .)
    SEMICOLON       reduce using rule 93 (ident -> IDENT .)
    RPAREN          reduce using rule 93 (ident -> IDENT .)
    LBRACKET        reduce using rule 93 (ident -> IDENT .)
    INC_OP          reduce using rule 93 (ident -> IDENT .)
    DEC_OP          reduce using rule 93 (ident -> IDENT .)
    MUL             reduce using rule 93 (ident -> IDENT .)
    DIV             reduce using rule 93 (ident -> IDENT .)
    MOD             reduce using rule 93 (ident -> IDENT .)
    ADD             reduce using rule 93 (ident -> IDENT .)
    SUB             reduce using rule 93 (ident -> IDENT .)
    GT              reduce using rule 93 (ident -> IDENT .)
    LT              reduce using rule 93 (ident -> IDENT .)
    GE              reduce using rule 93 (ident -> IDENT .)
    LE              reduce using rule 93 (ident -> IDENT .)
    EQUALS          reduce using rule 93 (ident -> IDENT .)
    NOTEQUALS       reduce using rule 93 (ident -> IDENT .)
    AND             reduce using rule 93 (ident -> IDENT .)
    OR              reduce using rule 93 (ident -> IDENT .)
    RBRACKET        reduce using rule 93 (ident -> IDENT .)
    RBRACE          reduce using rule 93 (ident -> IDENT .)
    LBRACE          reduce using rule 93 (ident -> IDENT .)
    IF              reduce using rule 93 (ident -> IDENT .)
    FOR             reduce using rule 93 (ident -> IDENT .)
    WHILE           reduce using rule 93 (ident -> IDENT .)
    DO              reduce using rule 93 (ident -> IDENT .)
    RETURN          reduce using rule 93 (ident -> IDENT .)
    CONTINUE        reduce using rule 93 (ident -> IDENT .)
    BREAK           reduce using rule 93 (ident -> IDENT .)
    IDENT           reduce using rule 93 (ident -> IDENT .)
    NOT             reduce using rule 93 (ident -> IDENT .)
    NUMBER          reduce using rule 93 (ident -> IDENT .)
    STRING          reduce using rule 93 (ident -> IDENT .)
    TRUE            reduce using rule 93 (ident -> IDENT .)
    FALSE           reduce using rule 93 (ident -> IDENT .)
    ELSE            reduce using rule 93 (ident -> IDENT .)
    ADD_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    SUB_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    MUL_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    DIV_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    MOD_ASSIGN      reduce using rule 93 (ident -> IDENT .)


state 17

    (101) init_declarator -> ident_initializer .

    COMMA           reduce using rule 101 (init_declarator -> ident_initializer .)
    SEMICOLON       reduce using rule 101 (init_declarator -> ident_initializer .)
    RPAREN          reduce using rule 101 (init_declarator -> ident_initializer .)


state 18

    (92) vars_declaration -> type_array init_array_declarator_list .
    (99) init_array_declarator_list -> init_array_declarator_list . COMMA init_array_declarator

  ! shift/reduce conflict for COMMA resolved as shift
    SEMICOLON       reduce using rule 92 (vars_declaration -> type_array init_array_declarator_list .)
    RPAREN          reduce using rule 92 (vars_declaration -> type_array init_array_declarator_list .)
    COMMA           shift and go to state 27

  ! COMMA           [ reduce using rule 92 (vars_declaration -> type_array init_array_declarator_list .) ]


state 19

    (98) init_array_declarator_list -> init_array_declarator .

    COMMA           reduce using rule 98 (init_array_declarator_list -> init_array_declarator .)
    SEMICOLON       reduce using rule 98 (init_array_declarator_list -> init_array_declarator .)
    RPAREN          reduce using rule 98 (init_array_declarator_list -> init_array_declarator .)


state 20

    (102) init_array_declarator -> array_ident .

    COMMA           reduce using rule 102 (init_array_declarator -> array_ident .)
    SEMICOLON       reduce using rule 102 (init_array_declarator -> array_ident .)
    RPAREN          reduce using rule 102 (init_array_declarator -> array_ident .)


state 21

    (103) init_array_declarator -> array_initializer .

    COMMA           reduce using rule 103 (init_array_declarator -> array_initializer .)
    SEMICOLON       reduce using rule 103 (init_array_declarator -> array_initializer .)
    RPAREN          reduce using rule 103 (init_array_declarator -> array_initializer .)


state 22

    (109) array_ident -> ident .
    (105) array_initializer -> ident . ASSIGN array_value

    COMMA           reduce using rule 109 (array_ident -> ident .)
    SEMICOLON       reduce using rule 109 (array_ident -> ident .)
    RPAREN          reduce using rule 109 (array_ident -> ident .)
    ASSIGN          shift and go to state 28


state 23

    (94) type_array -> IDENT BRACKETS .

    IDENT           reduce using rule 94 (type_array -> IDENT BRACKETS .)


state 24

    (97) init_declarator_list -> init_declarator_list COMMA . init_declarator
    (100) init_declarator -> . ident
    (101) init_declarator -> . ident_initializer
    (93) ident -> . IDENT
    (104) ident_initializer -> . ident ASSIGN simple_rvalue

    IDENT           shift and go to state 16

    init_declarator                shift and go to state 29
    ident                          shift and go to state 30
    ident_initializer              shift and go to state 17

state 25

    (83) function_definition -> type ident LPAREN . arguments_declaration_list RPAREN block
    (84) arguments_declaration_list -> .
    (85) arguments_declaration_list -> . argument_declaration
    (86) arguments_declaration_list -> . arguments_declaration_list COMMA argument_declaration
    (87) argument_declaration -> . type ident
    (95) type -> . IDENT

    RPAREN          reduce using rule 84 (arguments_declaration_list -> .)
    COMMA           reduce using rule 84 (arguments_declaration_list -> .)
    IDENT           shift and go to state 34

    type                           shift and go to state 31
    arguments_declaration_list     shift and go to state 32
    argument_declaration           shift and go to state 33

state 26

    (104) ident_initializer -> ident ASSIGN . simple_rvalue
    (79) simple_rvalue -> . logical_expression
    (80) simple_rvalue -> . lvalue ASSIGN simple_rvalue
    (34) logical_expression -> . logical_or_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    IDENT           shift and go to state 16
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    ident                          shift and go to state 35
    simple_rvalue                  shift and go to state 36
    logical_expression             shift and go to state 37
    lvalue                         shift and go to state 38
    logical_or_expression          shift and go to state 39
    get_element                    shift and go to state 40
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 27

    (99) init_array_declarator_list -> init_array_declarator_list COMMA . init_array_declarator
    (102) init_array_declarator -> . array_ident
    (103) init_array_declarator -> . array_initializer
    (109) array_ident -> . ident
    (105) array_initializer -> . ident ASSIGN array_value
    (93) ident -> . IDENT

    IDENT           shift and go to state 16

    init_array_declarator          shift and go to state 61
    array_ident                    shift and go to state 20
    array_initializer              shift and go to state 21
    ident                          shift and go to state 22

state 28

    (105) array_initializer -> ident ASSIGN . array_value
    (106) array_value -> . NEW type LBRACKET logical_expression RBRACKET
    (107) array_value -> . NEW type BRACKETS LBRACE args_list RBRACE
    (108) array_value -> . NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE

    NEW             shift and go to state 63

    array_value                    shift and go to state 62

state 29

    (97) init_declarator_list -> init_declarator_list COMMA init_declarator .

    COMMA           reduce using rule 97 (init_declarator_list -> init_declarator_list COMMA init_declarator .)
    SEMICOLON       reduce using rule 97 (init_declarator_list -> init_declarator_list COMMA init_declarator .)
    RPAREN          reduce using rule 97 (init_declarator_list -> init_declarator_list COMMA init_declarator .)


state 30

    (100) init_declarator -> ident .
    (104) ident_initializer -> ident . ASSIGN simple_rvalue

    COMMA           reduce using rule 100 (init_declarator -> ident .)
    SEMICOLON       reduce using rule 100 (init_declarator -> ident .)
    RPAREN          reduce using rule 100 (init_declarator -> ident .)
    ASSIGN          shift and go to state 26


state 31

    (87) argument_declaration -> type . ident
    (93) ident -> . IDENT

    IDENT           shift and go to state 16

    ident                          shift and go to state 64

state 32

    (83) function_definition -> type ident LPAREN arguments_declaration_list . RPAREN block
    (86) arguments_declaration_list -> arguments_declaration_list . COMMA argument_declaration

    RPAREN          shift and go to state 65
    COMMA           shift and go to state 66


state 33

    (85) arguments_declaration_list -> argument_declaration .

    RPAREN          reduce using rule 85 (arguments_declaration_list -> argument_declaration .)
    COMMA           reduce using rule 85 (arguments_declaration_list -> argument_declaration .)


state 34

    (95) type -> IDENT .

    IDENT           reduce using rule 95 (type -> IDENT .)
    LBRACKET        reduce using rule 95 (type -> IDENT .)
    BRACKETS        reduce using rule 95 (type -> IDENT .)


state 35

    (110) lvalue -> ident .
    (112) get_element -> ident . LBRACKET logical_expression RBRACKET
    (82) call -> ident . LPAREN args_list RPAREN

    ASSIGN          reduce using rule 110 (lvalue -> ident .)
    INC_OP          reduce using rule 110 (lvalue -> ident .)
    DEC_OP          reduce using rule 110 (lvalue -> ident .)
    MUL             reduce using rule 110 (lvalue -> ident .)
    DIV             reduce using rule 110 (lvalue -> ident .)
    MOD             reduce using rule 110 (lvalue -> ident .)
    ADD             reduce using rule 110 (lvalue -> ident .)
    SUB             reduce using rule 110 (lvalue -> ident .)
    GT              reduce using rule 110 (lvalue -> ident .)
    LT              reduce using rule 110 (lvalue -> ident .)
    GE              reduce using rule 110 (lvalue -> ident .)
    LE              reduce using rule 110 (lvalue -> ident .)
    EQUALS          reduce using rule 110 (lvalue -> ident .)
    NOTEQUALS       reduce using rule 110 (lvalue -> ident .)
    AND             reduce using rule 110 (lvalue -> ident .)
    OR              reduce using rule 110 (lvalue -> ident .)
    COMMA           reduce using rule 110 (lvalue -> ident .)
    SEMICOLON       reduce using rule 110 (lvalue -> ident .)
    RPAREN          reduce using rule 110 (lvalue -> ident .)
    ADD_ASSIGN      reduce using rule 110 (lvalue -> ident .)
    SUB_ASSIGN      reduce using rule 110 (lvalue -> ident .)
    MUL_ASSIGN      reduce using rule 110 (lvalue -> ident .)
    DIV_ASSIGN      reduce using rule 110 (lvalue -> ident .)
    MOD_ASSIGN      reduce using rule 110 (lvalue -> ident .)
    LBRACKET        shift and go to state 67
    LPAREN          shift and go to state 68


state 36

    (104) ident_initializer -> ident ASSIGN simple_rvalue .

    COMMA           reduce using rule 104 (ident_initializer -> ident ASSIGN simple_rvalue .)
    SEMICOLON       reduce using rule 104 (ident_initializer -> ident ASSIGN simple_rvalue .)
    RPAREN          reduce using rule 104 (ident_initializer -> ident ASSIGN simple_rvalue .)


state 37

    (79) simple_rvalue -> logical_expression .

    COMMA           reduce using rule 79 (simple_rvalue -> logical_expression .)
    SEMICOLON       reduce using rule 79 (simple_rvalue -> logical_expression .)
    RPAREN          reduce using rule 79 (simple_rvalue -> logical_expression .)


state 38

    (80) simple_rvalue -> lvalue . ASSIGN simple_rvalue
    (59) postfix_expression -> lvalue . INC_OP
    (60) postfix_expression -> lvalue . DEC_OP
    (62) group -> lvalue .

    ASSIGN          shift and go to state 69
    INC_OP          shift and go to state 70
    DEC_OP          shift and go to state 71
    MUL             reduce using rule 62 (group -> lvalue .)
    DIV             reduce using rule 62 (group -> lvalue .)
    MOD             reduce using rule 62 (group -> lvalue .)
    ADD             reduce using rule 62 (group -> lvalue .)
    SUB             reduce using rule 62 (group -> lvalue .)
    GT              reduce using rule 62 (group -> lvalue .)
    LT              reduce using rule 62 (group -> lvalue .)
    GE              reduce using rule 62 (group -> lvalue .)
    LE              reduce using rule 62 (group -> lvalue .)
    EQUALS          reduce using rule 62 (group -> lvalue .)
    NOTEQUALS       reduce using rule 62 (group -> lvalue .)
    AND             reduce using rule 62 (group -> lvalue .)
    OR              reduce using rule 62 (group -> lvalue .)
    COMMA           reduce using rule 62 (group -> lvalue .)
    SEMICOLON       reduce using rule 62 (group -> lvalue .)
    RPAREN          reduce using rule 62 (group -> lvalue .)


state 39

    (34) logical_expression -> logical_or_expression .
    (36) logical_or_expression -> logical_or_expression . OR logical_and_expression

    COMMA           reduce using rule 34 (logical_expression -> logical_or_expression .)
    SEMICOLON       reduce using rule 34 (logical_expression -> logical_or_expression .)
    RPAREN          reduce using rule 34 (logical_expression -> logical_or_expression .)
    RBRACKET        reduce using rule 34 (logical_expression -> logical_or_expression .)
    RBRACE          reduce using rule 34 (logical_expression -> logical_or_expression .)
    LBRACE          reduce using rule 34 (logical_expression -> logical_or_expression .)
    IF              reduce using rule 34 (logical_expression -> logical_or_expression .)
    FOR             reduce using rule 34 (logical_expression -> logical_or_expression .)
    WHILE           reduce using rule 34 (logical_expression -> logical_or_expression .)
    DO              reduce using rule 34 (logical_expression -> logical_or_expression .)
    RETURN          reduce using rule 34 (logical_expression -> logical_or_expression .)
    CONTINUE        reduce using rule 34 (logical_expression -> logical_or_expression .)
    BREAK           reduce using rule 34 (logical_expression -> logical_or_expression .)
    IDENT           reduce using rule 34 (logical_expression -> logical_or_expression .)
    NOT             reduce using rule 34 (logical_expression -> logical_or_expression .)
    SUB             reduce using rule 34 (logical_expression -> logical_or_expression .)
    ADD             reduce using rule 34 (logical_expression -> logical_or_expression .)
    LPAREN          reduce using rule 34 (logical_expression -> logical_or_expression .)
    NUMBER          reduce using rule 34 (logical_expression -> logical_or_expression .)
    STRING          reduce using rule 34 (logical_expression -> logical_or_expression .)
    TRUE            reduce using rule 34 (logical_expression -> logical_or_expression .)
    FALSE           reduce using rule 34 (logical_expression -> logical_or_expression .)
    ELSE            reduce using rule 34 (logical_expression -> logical_or_expression .)
    OR              shift and go to state 72


state 40

    (111) lvalue -> get_element .

    ASSIGN          reduce using rule 111 (lvalue -> get_element .)
    INC_OP          reduce using rule 111 (lvalue -> get_element .)
    DEC_OP          reduce using rule 111 (lvalue -> get_element .)
    MUL             reduce using rule 111 (lvalue -> get_element .)
    DIV             reduce using rule 111 (lvalue -> get_element .)
    MOD             reduce using rule 111 (lvalue -> get_element .)
    ADD             reduce using rule 111 (lvalue -> get_element .)
    SUB             reduce using rule 111 (lvalue -> get_element .)
    GT              reduce using rule 111 (lvalue -> get_element .)
    LT              reduce using rule 111 (lvalue -> get_element .)
    GE              reduce using rule 111 (lvalue -> get_element .)
    LE              reduce using rule 111 (lvalue -> get_element .)
    EQUALS          reduce using rule 111 (lvalue -> get_element .)
    NOTEQUALS       reduce using rule 111 (lvalue -> get_element .)
    AND             reduce using rule 111 (lvalue -> get_element .)
    OR              reduce using rule 111 (lvalue -> get_element .)
    COMMA           reduce using rule 111 (lvalue -> get_element .)
    SEMICOLON       reduce using rule 111 (lvalue -> get_element .)
    RPAREN          reduce using rule 111 (lvalue -> get_element .)
    RBRACKET        reduce using rule 111 (lvalue -> get_element .)
    RBRACE          reduce using rule 111 (lvalue -> get_element .)
    LBRACE          reduce using rule 111 (lvalue -> get_element .)
    IF              reduce using rule 111 (lvalue -> get_element .)
    FOR             reduce using rule 111 (lvalue -> get_element .)
    WHILE           reduce using rule 111 (lvalue -> get_element .)
    DO              reduce using rule 111 (lvalue -> get_element .)
    RETURN          reduce using rule 111 (lvalue -> get_element .)
    CONTINUE        reduce using rule 111 (lvalue -> get_element .)
    BREAK           reduce using rule 111 (lvalue -> get_element .)
    IDENT           reduce using rule 111 (lvalue -> get_element .)
    NOT             reduce using rule 111 (lvalue -> get_element .)
    LPAREN          reduce using rule 111 (lvalue -> get_element .)
    NUMBER          reduce using rule 111 (lvalue -> get_element .)
    STRING          reduce using rule 111 (lvalue -> get_element .)
    TRUE            reduce using rule 111 (lvalue -> get_element .)
    FALSE           reduce using rule 111 (lvalue -> get_element .)
    ELSE            reduce using rule 111 (lvalue -> get_element .)
    ADD_ASSIGN      reduce using rule 111 (lvalue -> get_element .)
    SUB_ASSIGN      reduce using rule 111 (lvalue -> get_element .)
    MUL_ASSIGN      reduce using rule 111 (lvalue -> get_element .)
    DIV_ASSIGN      reduce using rule 111 (lvalue -> get_element .)
    MOD_ASSIGN      reduce using rule 111 (lvalue -> get_element .)


state 41

    (35) logical_or_expression -> logical_and_expression .
    (38) logical_and_expression -> logical_and_expression . AND equality_expression

    OR              reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    COMMA           reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    SEMICOLON       reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    RPAREN          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    RBRACKET        reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    RBRACE          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    LBRACE          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    IF              reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    FOR             reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    WHILE           reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    DO              reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    RETURN          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    CONTINUE        reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    BREAK           reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    IDENT           reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    NOT             reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    SUB             reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    ADD             reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    LPAREN          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    NUMBER          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    STRING          reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    TRUE            reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    FALSE           reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    ELSE            reduce using rule 35 (logical_or_expression -> logical_and_expression .)
    AND             shift and go to state 73


state 42

    (37) logical_and_expression -> equality_expression .
    (40) equality_expression -> equality_expression . EQUALS relational_expression
    (41) equality_expression -> equality_expression . NOTEQUALS relational_expression

    AND             reduce using rule 37 (logical_and_expression -> equality_expression .)
    OR              reduce using rule 37 (logical_and_expression -> equality_expression .)
    COMMA           reduce using rule 37 (logical_and_expression -> equality_expression .)
    SEMICOLON       reduce using rule 37 (logical_and_expression -> equality_expression .)
    RPAREN          reduce using rule 37 (logical_and_expression -> equality_expression .)
    RBRACKET        reduce using rule 37 (logical_and_expression -> equality_expression .)
    RBRACE          reduce using rule 37 (logical_and_expression -> equality_expression .)
    LBRACE          reduce using rule 37 (logical_and_expression -> equality_expression .)
    IF              reduce using rule 37 (logical_and_expression -> equality_expression .)
    FOR             reduce using rule 37 (logical_and_expression -> equality_expression .)
    WHILE           reduce using rule 37 (logical_and_expression -> equality_expression .)
    DO              reduce using rule 37 (logical_and_expression -> equality_expression .)
    RETURN          reduce using rule 37 (logical_and_expression -> equality_expression .)
    CONTINUE        reduce using rule 37 (logical_and_expression -> equality_expression .)
    BREAK           reduce using rule 37 (logical_and_expression -> equality_expression .)
    IDENT           reduce using rule 37 (logical_and_expression -> equality_expression .)
    NOT             reduce using rule 37 (logical_and_expression -> equality_expression .)
    SUB             reduce using rule 37 (logical_and_expression -> equality_expression .)
    ADD             reduce using rule 37 (logical_and_expression -> equality_expression .)
    LPAREN          reduce using rule 37 (logical_and_expression -> equality_expression .)
    NUMBER          reduce using rule 37 (logical_and_expression -> equality_expression .)
    STRING          reduce using rule 37 (logical_and_expression -> equality_expression .)
    TRUE            reduce using rule 37 (logical_and_expression -> equality_expression .)
    FALSE           reduce using rule 37 (logical_and_expression -> equality_expression .)
    ELSE            reduce using rule 37 (logical_and_expression -> equality_expression .)
    EQUALS          shift and go to state 74
    NOTEQUALS       shift and go to state 75


state 43

    (39) equality_expression -> relational_expression .
    (43) relational_expression -> relational_expression . GT additive_expression
    (44) relational_expression -> relational_expression . LT additive_expression
    (45) relational_expression -> relational_expression . GE additive_expression
    (46) relational_expression -> relational_expression . LE additive_expression

    EQUALS          reduce using rule 39 (equality_expression -> relational_expression .)
    NOTEQUALS       reduce using rule 39 (equality_expression -> relational_expression .)
    AND             reduce using rule 39 (equality_expression -> relational_expression .)
    OR              reduce using rule 39 (equality_expression -> relational_expression .)
    COMMA           reduce using rule 39 (equality_expression -> relational_expression .)
    SEMICOLON       reduce using rule 39 (equality_expression -> relational_expression .)
    RPAREN          reduce using rule 39 (equality_expression -> relational_expression .)
    RBRACKET        reduce using rule 39 (equality_expression -> relational_expression .)
    RBRACE          reduce using rule 39 (equality_expression -> relational_expression .)
    LBRACE          reduce using rule 39 (equality_expression -> relational_expression .)
    IF              reduce using rule 39 (equality_expression -> relational_expression .)
    FOR             reduce using rule 39 (equality_expression -> relational_expression .)
    WHILE           reduce using rule 39 (equality_expression -> relational_expression .)
    DO              reduce using rule 39 (equality_expression -> relational_expression .)
    RETURN          reduce using rule 39 (equality_expression -> relational_expression .)
    CONTINUE        reduce using rule 39 (equality_expression -> relational_expression .)
    BREAK           reduce using rule 39 (equality_expression -> relational_expression .)
    IDENT           reduce using rule 39 (equality_expression -> relational_expression .)
    NOT             reduce using rule 39 (equality_expression -> relational_expression .)
    SUB             reduce using rule 39 (equality_expression -> relational_expression .)
    ADD             reduce using rule 39 (equality_expression -> relational_expression .)
    LPAREN          reduce using rule 39 (equality_expression -> relational_expression .)
    NUMBER          reduce using rule 39 (equality_expression -> relational_expression .)
    STRING          reduce using rule 39 (equality_expression -> relational_expression .)
    TRUE            reduce using rule 39 (equality_expression -> relational_expression .)
    FALSE           reduce using rule 39 (equality_expression -> relational_expression .)
    ELSE            reduce using rule 39 (equality_expression -> relational_expression .)
    GT              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79


state 44

    (42) relational_expression -> additive_expression .
    (48) additive_expression -> additive_expression . ADD multiplicative_expression
    (49) additive_expression -> additive_expression . SUB multiplicative_expression

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    GT              reduce using rule 42 (relational_expression -> additive_expression .)
    LT              reduce using rule 42 (relational_expression -> additive_expression .)
    GE              reduce using rule 42 (relational_expression -> additive_expression .)
    LE              reduce using rule 42 (relational_expression -> additive_expression .)
    EQUALS          reduce using rule 42 (relational_expression -> additive_expression .)
    NOTEQUALS       reduce using rule 42 (relational_expression -> additive_expression .)
    AND             reduce using rule 42 (relational_expression -> additive_expression .)
    OR              reduce using rule 42 (relational_expression -> additive_expression .)
    COMMA           reduce using rule 42 (relational_expression -> additive_expression .)
    SEMICOLON       reduce using rule 42 (relational_expression -> additive_expression .)
    RPAREN          reduce using rule 42 (relational_expression -> additive_expression .)
    RBRACKET        reduce using rule 42 (relational_expression -> additive_expression .)
    RBRACE          reduce using rule 42 (relational_expression -> additive_expression .)
    LBRACE          reduce using rule 42 (relational_expression -> additive_expression .)
    IF              reduce using rule 42 (relational_expression -> additive_expression .)
    FOR             reduce using rule 42 (relational_expression -> additive_expression .)
    WHILE           reduce using rule 42 (relational_expression -> additive_expression .)
    DO              reduce using rule 42 (relational_expression -> additive_expression .)
    RETURN          reduce using rule 42 (relational_expression -> additive_expression .)
    CONTINUE        reduce using rule 42 (relational_expression -> additive_expression .)
    BREAK           reduce using rule 42 (relational_expression -> additive_expression .)
    IDENT           reduce using rule 42 (relational_expression -> additive_expression .)
    NOT             reduce using rule 42 (relational_expression -> additive_expression .)
    LPAREN          reduce using rule 42 (relational_expression -> additive_expression .)
    NUMBER          reduce using rule 42 (relational_expression -> additive_expression .)
    STRING          reduce using rule 42 (relational_expression -> additive_expression .)
    TRUE            reduce using rule 42 (relational_expression -> additive_expression .)
    FALSE           reduce using rule 42 (relational_expression -> additive_expression .)
    ELSE            reduce using rule 42 (relational_expression -> additive_expression .)
    ADD             shift and go to state 80
    SUB             shift and go to state 81

  ! SUB             [ reduce using rule 42 (relational_expression -> additive_expression .) ]
  ! ADD             [ reduce using rule 42 (relational_expression -> additive_expression .) ]


state 45

    (47) additive_expression -> multiplicative_expression .
    (51) multiplicative_expression -> multiplicative_expression . MUL unary_expression
    (52) multiplicative_expression -> multiplicative_expression . DIV unary_expression
    (53) multiplicative_expression -> multiplicative_expression . MOD unary_expression

    ADD             reduce using rule 47 (additive_expression -> multiplicative_expression .)
    SUB             reduce using rule 47 (additive_expression -> multiplicative_expression .)
    GT              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    LT              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    GE              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    LE              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    EQUALS          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    NOTEQUALS       reduce using rule 47 (additive_expression -> multiplicative_expression .)
    AND             reduce using rule 47 (additive_expression -> multiplicative_expression .)
    OR              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    COMMA           reduce using rule 47 (additive_expression -> multiplicative_expression .)
    SEMICOLON       reduce using rule 47 (additive_expression -> multiplicative_expression .)
    RPAREN          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    RBRACKET        reduce using rule 47 (additive_expression -> multiplicative_expression .)
    RBRACE          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    LBRACE          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    IF              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    FOR             reduce using rule 47 (additive_expression -> multiplicative_expression .)
    WHILE           reduce using rule 47 (additive_expression -> multiplicative_expression .)
    DO              reduce using rule 47 (additive_expression -> multiplicative_expression .)
    RETURN          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    CONTINUE        reduce using rule 47 (additive_expression -> multiplicative_expression .)
    BREAK           reduce using rule 47 (additive_expression -> multiplicative_expression .)
    IDENT           reduce using rule 47 (additive_expression -> multiplicative_expression .)
    NOT             reduce using rule 47 (additive_expression -> multiplicative_expression .)
    LPAREN          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    NUMBER          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    STRING          reduce using rule 47 (additive_expression -> multiplicative_expression .)
    TRUE            reduce using rule 47 (additive_expression -> multiplicative_expression .)
    FALSE           reduce using rule 47 (additive_expression -> multiplicative_expression .)
    ELSE            reduce using rule 47 (additive_expression -> multiplicative_expression .)
    MUL             shift and go to state 82
    DIV             shift and go to state 83
    MOD             shift and go to state 84


state 46

    (57) unary_expression -> ADD . group
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    group                          shift and go to state 85
    call                           shift and go to state 52
    lvalue                         shift and go to state 86
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 87
    get_element                    shift and go to state 40

state 47

    (56) unary_expression -> SUB . group
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    group                          shift and go to state 88
    call                           shift and go to state 52
    lvalue                         shift and go to state 86
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 87
    get_element                    shift and go to state 40

state 48

    (50) multiplicative_expression -> unary_expression .

    MUL             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    DIV             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    MOD             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    ADD             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    SUB             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    GT              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    LT              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    GE              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    LE              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    EQUALS          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    NOTEQUALS       reduce using rule 50 (multiplicative_expression -> unary_expression .)
    AND             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    OR              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    COMMA           reduce using rule 50 (multiplicative_expression -> unary_expression .)
    SEMICOLON       reduce using rule 50 (multiplicative_expression -> unary_expression .)
    RPAREN          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    RBRACKET        reduce using rule 50 (multiplicative_expression -> unary_expression .)
    RBRACE          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    LBRACE          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    IF              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    FOR             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    WHILE           reduce using rule 50 (multiplicative_expression -> unary_expression .)
    DO              reduce using rule 50 (multiplicative_expression -> unary_expression .)
    RETURN          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    CONTINUE        reduce using rule 50 (multiplicative_expression -> unary_expression .)
    BREAK           reduce using rule 50 (multiplicative_expression -> unary_expression .)
    IDENT           reduce using rule 50 (multiplicative_expression -> unary_expression .)
    NOT             reduce using rule 50 (multiplicative_expression -> unary_expression .)
    LPAREN          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    NUMBER          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    STRING          reduce using rule 50 (multiplicative_expression -> unary_expression .)
    TRUE            reduce using rule 50 (multiplicative_expression -> unary_expression .)
    FALSE           reduce using rule 50 (multiplicative_expression -> unary_expression .)
    ELSE            reduce using rule 50 (multiplicative_expression -> unary_expression .)


state 49

    (54) unary_expression -> postfix_expression .

    MUL             reduce using rule 54 (unary_expression -> postfix_expression .)
    DIV             reduce using rule 54 (unary_expression -> postfix_expression .)
    MOD             reduce using rule 54 (unary_expression -> postfix_expression .)
    ADD             reduce using rule 54 (unary_expression -> postfix_expression .)
    SUB             reduce using rule 54 (unary_expression -> postfix_expression .)
    GT              reduce using rule 54 (unary_expression -> postfix_expression .)
    LT              reduce using rule 54 (unary_expression -> postfix_expression .)
    GE              reduce using rule 54 (unary_expression -> postfix_expression .)
    LE              reduce using rule 54 (unary_expression -> postfix_expression .)
    EQUALS          reduce using rule 54 (unary_expression -> postfix_expression .)
    NOTEQUALS       reduce using rule 54 (unary_expression -> postfix_expression .)
    AND             reduce using rule 54 (unary_expression -> postfix_expression .)
    OR              reduce using rule 54 (unary_expression -> postfix_expression .)
    COMMA           reduce using rule 54 (unary_expression -> postfix_expression .)
    SEMICOLON       reduce using rule 54 (unary_expression -> postfix_expression .)
    RPAREN          reduce using rule 54 (unary_expression -> postfix_expression .)
    RBRACKET        reduce using rule 54 (unary_expression -> postfix_expression .)
    RBRACE          reduce using rule 54 (unary_expression -> postfix_expression .)
    LBRACE          reduce using rule 54 (unary_expression -> postfix_expression .)
    IF              reduce using rule 54 (unary_expression -> postfix_expression .)
    FOR             reduce using rule 54 (unary_expression -> postfix_expression .)
    WHILE           reduce using rule 54 (unary_expression -> postfix_expression .)
    DO              reduce using rule 54 (unary_expression -> postfix_expression .)
    RETURN          reduce using rule 54 (unary_expression -> postfix_expression .)
    CONTINUE        reduce using rule 54 (unary_expression -> postfix_expression .)
    BREAK           reduce using rule 54 (unary_expression -> postfix_expression .)
    IDENT           reduce using rule 54 (unary_expression -> postfix_expression .)
    NOT             reduce using rule 54 (unary_expression -> postfix_expression .)
    LPAREN          reduce using rule 54 (unary_expression -> postfix_expression .)
    NUMBER          reduce using rule 54 (unary_expression -> postfix_expression .)
    STRING          reduce using rule 54 (unary_expression -> postfix_expression .)
    TRUE            reduce using rule 54 (unary_expression -> postfix_expression .)
    FALSE           reduce using rule 54 (unary_expression -> postfix_expression .)
    ELSE            reduce using rule 54 (unary_expression -> postfix_expression .)


state 50

    (55) unary_expression -> NOT . group
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    group                          shift and go to state 89
    call                           shift and go to state 52
    lvalue                         shift and go to state 86
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 87
    get_element                    shift and go to state 40

state 51

    (58) postfix_expression -> group .

    MUL             reduce using rule 58 (postfix_expression -> group .)
    DIV             reduce using rule 58 (postfix_expression -> group .)
    MOD             reduce using rule 58 (postfix_expression -> group .)
    ADD             reduce using rule 58 (postfix_expression -> group .)
    SUB             reduce using rule 58 (postfix_expression -> group .)
    GT              reduce using rule 58 (postfix_expression -> group .)
    LT              reduce using rule 58 (postfix_expression -> group .)
    GE              reduce using rule 58 (postfix_expression -> group .)
    LE              reduce using rule 58 (postfix_expression -> group .)
    EQUALS          reduce using rule 58 (postfix_expression -> group .)
    NOTEQUALS       reduce using rule 58 (postfix_expression -> group .)
    AND             reduce using rule 58 (postfix_expression -> group .)
    OR              reduce using rule 58 (postfix_expression -> group .)
    COMMA           reduce using rule 58 (postfix_expression -> group .)
    SEMICOLON       reduce using rule 58 (postfix_expression -> group .)
    RPAREN          reduce using rule 58 (postfix_expression -> group .)
    RBRACKET        reduce using rule 58 (postfix_expression -> group .)
    RBRACE          reduce using rule 58 (postfix_expression -> group .)
    LBRACE          reduce using rule 58 (postfix_expression -> group .)
    IF              reduce using rule 58 (postfix_expression -> group .)
    FOR             reduce using rule 58 (postfix_expression -> group .)
    WHILE           reduce using rule 58 (postfix_expression -> group .)
    DO              reduce using rule 58 (postfix_expression -> group .)
    RETURN          reduce using rule 58 (postfix_expression -> group .)
    CONTINUE        reduce using rule 58 (postfix_expression -> group .)
    BREAK           reduce using rule 58 (postfix_expression -> group .)
    IDENT           reduce using rule 58 (postfix_expression -> group .)
    NOT             reduce using rule 58 (postfix_expression -> group .)
    LPAREN          reduce using rule 58 (postfix_expression -> group .)
    NUMBER          reduce using rule 58 (postfix_expression -> group .)
    STRING          reduce using rule 58 (postfix_expression -> group .)
    TRUE            reduce using rule 58 (postfix_expression -> group .)
    FALSE           reduce using rule 58 (postfix_expression -> group .)
    ELSE            reduce using rule 58 (postfix_expression -> group .)


state 52

    (61) group -> call .

    MUL             reduce using rule 61 (group -> call .)
    DIV             reduce using rule 61 (group -> call .)
    MOD             reduce using rule 61 (group -> call .)
    ADD             reduce using rule 61 (group -> call .)
    SUB             reduce using rule 61 (group -> call .)
    GT              reduce using rule 61 (group -> call .)
    LT              reduce using rule 61 (group -> call .)
    GE              reduce using rule 61 (group -> call .)
    LE              reduce using rule 61 (group -> call .)
    EQUALS          reduce using rule 61 (group -> call .)
    NOTEQUALS       reduce using rule 61 (group -> call .)
    AND             reduce using rule 61 (group -> call .)
    OR              reduce using rule 61 (group -> call .)
    COMMA           reduce using rule 61 (group -> call .)
    SEMICOLON       reduce using rule 61 (group -> call .)
    RPAREN          reduce using rule 61 (group -> call .)
    RBRACKET        reduce using rule 61 (group -> call .)
    RBRACE          reduce using rule 61 (group -> call .)
    LBRACE          reduce using rule 61 (group -> call .)
    IF              reduce using rule 61 (group -> call .)
    FOR             reduce using rule 61 (group -> call .)
    WHILE           reduce using rule 61 (group -> call .)
    DO              reduce using rule 61 (group -> call .)
    RETURN          reduce using rule 61 (group -> call .)
    CONTINUE        reduce using rule 61 (group -> call .)
    BREAK           reduce using rule 61 (group -> call .)
    IDENT           reduce using rule 61 (group -> call .)
    NOT             reduce using rule 61 (group -> call .)
    LPAREN          reduce using rule 61 (group -> call .)
    NUMBER          reduce using rule 61 (group -> call .)
    STRING          reduce using rule 61 (group -> call .)
    TRUE            reduce using rule 61 (group -> call .)
    FALSE           reduce using rule 61 (group -> call .)
    ELSE            reduce using rule 61 (group -> call .)


state 53

    (63) group -> LPAREN . logical_expression RPAREN
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 90
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 54

    (64) group -> number .

    MUL             reduce using rule 64 (group -> number .)
    DIV             reduce using rule 64 (group -> number .)
    MOD             reduce using rule 64 (group -> number .)
    ADD             reduce using rule 64 (group -> number .)
    SUB             reduce using rule 64 (group -> number .)
    GT              reduce using rule 64 (group -> number .)
    LT              reduce using rule 64 (group -> number .)
    GE              reduce using rule 64 (group -> number .)
    LE              reduce using rule 64 (group -> number .)
    EQUALS          reduce using rule 64 (group -> number .)
    NOTEQUALS       reduce using rule 64 (group -> number .)
    AND             reduce using rule 64 (group -> number .)
    OR              reduce using rule 64 (group -> number .)
    COMMA           reduce using rule 64 (group -> number .)
    SEMICOLON       reduce using rule 64 (group -> number .)
    RPAREN          reduce using rule 64 (group -> number .)
    RBRACKET        reduce using rule 64 (group -> number .)
    RBRACE          reduce using rule 64 (group -> number .)
    LBRACE          reduce using rule 64 (group -> number .)
    IF              reduce using rule 64 (group -> number .)
    FOR             reduce using rule 64 (group -> number .)
    WHILE           reduce using rule 64 (group -> number .)
    DO              reduce using rule 64 (group -> number .)
    RETURN          reduce using rule 64 (group -> number .)
    CONTINUE        reduce using rule 64 (group -> number .)
    BREAK           reduce using rule 64 (group -> number .)
    IDENT           reduce using rule 64 (group -> number .)
    NOT             reduce using rule 64 (group -> number .)
    LPAREN          reduce using rule 64 (group -> number .)
    NUMBER          reduce using rule 64 (group -> number .)
    STRING          reduce using rule 64 (group -> number .)
    TRUE            reduce using rule 64 (group -> number .)
    FALSE           reduce using rule 64 (group -> number .)
    ELSE            reduce using rule 64 (group -> number .)


state 55

    (65) group -> string .

    MUL             reduce using rule 65 (group -> string .)
    DIV             reduce using rule 65 (group -> string .)
    MOD             reduce using rule 65 (group -> string .)
    ADD             reduce using rule 65 (group -> string .)
    SUB             reduce using rule 65 (group -> string .)
    GT              reduce using rule 65 (group -> string .)
    LT              reduce using rule 65 (group -> string .)
    GE              reduce using rule 65 (group -> string .)
    LE              reduce using rule 65 (group -> string .)
    EQUALS          reduce using rule 65 (group -> string .)
    NOTEQUALS       reduce using rule 65 (group -> string .)
    AND             reduce using rule 65 (group -> string .)
    OR              reduce using rule 65 (group -> string .)
    COMMA           reduce using rule 65 (group -> string .)
    SEMICOLON       reduce using rule 65 (group -> string .)
    RPAREN          reduce using rule 65 (group -> string .)
    RBRACKET        reduce using rule 65 (group -> string .)
    RBRACE          reduce using rule 65 (group -> string .)
    LBRACE          reduce using rule 65 (group -> string .)
    IF              reduce using rule 65 (group -> string .)
    FOR             reduce using rule 65 (group -> string .)
    WHILE           reduce using rule 65 (group -> string .)
    DO              reduce using rule 65 (group -> string .)
    RETURN          reduce using rule 65 (group -> string .)
    CONTINUE        reduce using rule 65 (group -> string .)
    BREAK           reduce using rule 65 (group -> string .)
    IDENT           reduce using rule 65 (group -> string .)
    NOT             reduce using rule 65 (group -> string .)
    LPAREN          reduce using rule 65 (group -> string .)
    NUMBER          reduce using rule 65 (group -> string .)
    STRING          reduce using rule 65 (group -> string .)
    TRUE            reduce using rule 65 (group -> string .)
    FALSE           reduce using rule 65 (group -> string .)
    ELSE            reduce using rule 65 (group -> string .)


state 56

    (66) group -> bool_value .

    MUL             reduce using rule 66 (group -> bool_value .)
    DIV             reduce using rule 66 (group -> bool_value .)
    MOD             reduce using rule 66 (group -> bool_value .)
    ADD             reduce using rule 66 (group -> bool_value .)
    SUB             reduce using rule 66 (group -> bool_value .)
    GT              reduce using rule 66 (group -> bool_value .)
    LT              reduce using rule 66 (group -> bool_value .)
    GE              reduce using rule 66 (group -> bool_value .)
    LE              reduce using rule 66 (group -> bool_value .)
    EQUALS          reduce using rule 66 (group -> bool_value .)
    NOTEQUALS       reduce using rule 66 (group -> bool_value .)
    AND             reduce using rule 66 (group -> bool_value .)
    OR              reduce using rule 66 (group -> bool_value .)
    COMMA           reduce using rule 66 (group -> bool_value .)
    SEMICOLON       reduce using rule 66 (group -> bool_value .)
    RPAREN          reduce using rule 66 (group -> bool_value .)
    RBRACKET        reduce using rule 66 (group -> bool_value .)
    RBRACE          reduce using rule 66 (group -> bool_value .)
    LBRACE          reduce using rule 66 (group -> bool_value .)
    IF              reduce using rule 66 (group -> bool_value .)
    FOR             reduce using rule 66 (group -> bool_value .)
    WHILE           reduce using rule 66 (group -> bool_value .)
    DO              reduce using rule 66 (group -> bool_value .)
    RETURN          reduce using rule 66 (group -> bool_value .)
    CONTINUE        reduce using rule 66 (group -> bool_value .)
    BREAK           reduce using rule 66 (group -> bool_value .)
    IDENT           reduce using rule 66 (group -> bool_value .)
    NOT             reduce using rule 66 (group -> bool_value .)
    LPAREN          reduce using rule 66 (group -> bool_value .)
    NUMBER          reduce using rule 66 (group -> bool_value .)
    STRING          reduce using rule 66 (group -> bool_value .)
    TRUE            reduce using rule 66 (group -> bool_value .)
    FALSE           reduce using rule 66 (group -> bool_value .)
    ELSE            reduce using rule 66 (group -> bool_value .)


state 57

    (120) number -> NUMBER .

    MUL             reduce using rule 120 (number -> NUMBER .)
    DIV             reduce using rule 120 (number -> NUMBER .)
    MOD             reduce using rule 120 (number -> NUMBER .)
    ADD             reduce using rule 120 (number -> NUMBER .)
    SUB             reduce using rule 120 (number -> NUMBER .)
    GT              reduce using rule 120 (number -> NUMBER .)
    LT              reduce using rule 120 (number -> NUMBER .)
    GE              reduce using rule 120 (number -> NUMBER .)
    LE              reduce using rule 120 (number -> NUMBER .)
    EQUALS          reduce using rule 120 (number -> NUMBER .)
    NOTEQUALS       reduce using rule 120 (number -> NUMBER .)
    AND             reduce using rule 120 (number -> NUMBER .)
    OR              reduce using rule 120 (number -> NUMBER .)
    COMMA           reduce using rule 120 (number -> NUMBER .)
    SEMICOLON       reduce using rule 120 (number -> NUMBER .)
    RPAREN          reduce using rule 120 (number -> NUMBER .)
    RBRACKET        reduce using rule 120 (number -> NUMBER .)
    RBRACE          reduce using rule 120 (number -> NUMBER .)
    LBRACE          reduce using rule 120 (number -> NUMBER .)
    IF              reduce using rule 120 (number -> NUMBER .)
    FOR             reduce using rule 120 (number -> NUMBER .)
    WHILE           reduce using rule 120 (number -> NUMBER .)
    DO              reduce using rule 120 (number -> NUMBER .)
    RETURN          reduce using rule 120 (number -> NUMBER .)
    CONTINUE        reduce using rule 120 (number -> NUMBER .)
    BREAK           reduce using rule 120 (number -> NUMBER .)
    IDENT           reduce using rule 120 (number -> NUMBER .)
    NOT             reduce using rule 120 (number -> NUMBER .)
    LPAREN          reduce using rule 120 (number -> NUMBER .)
    NUMBER          reduce using rule 120 (number -> NUMBER .)
    STRING          reduce using rule 120 (number -> NUMBER .)
    TRUE            reduce using rule 120 (number -> NUMBER .)
    FALSE           reduce using rule 120 (number -> NUMBER .)
    ELSE            reduce using rule 120 (number -> NUMBER .)


state 58

    (81) string -> STRING .

    MUL             reduce using rule 81 (string -> STRING .)
    DIV             reduce using rule 81 (string -> STRING .)
    MOD             reduce using rule 81 (string -> STRING .)
    ADD             reduce using rule 81 (string -> STRING .)
    SUB             reduce using rule 81 (string -> STRING .)
    GT              reduce using rule 81 (string -> STRING .)
    LT              reduce using rule 81 (string -> STRING .)
    GE              reduce using rule 81 (string -> STRING .)
    LE              reduce using rule 81 (string -> STRING .)
    EQUALS          reduce using rule 81 (string -> STRING .)
    NOTEQUALS       reduce using rule 81 (string -> STRING .)
    AND             reduce using rule 81 (string -> STRING .)
    OR              reduce using rule 81 (string -> STRING .)
    COMMA           reduce using rule 81 (string -> STRING .)
    SEMICOLON       reduce using rule 81 (string -> STRING .)
    RPAREN          reduce using rule 81 (string -> STRING .)
    RBRACKET        reduce using rule 81 (string -> STRING .)
    RBRACE          reduce using rule 81 (string -> STRING .)
    LBRACE          reduce using rule 81 (string -> STRING .)
    IF              reduce using rule 81 (string -> STRING .)
    FOR             reduce using rule 81 (string -> STRING .)
    WHILE           reduce using rule 81 (string -> STRING .)
    DO              reduce using rule 81 (string -> STRING .)
    RETURN          reduce using rule 81 (string -> STRING .)
    CONTINUE        reduce using rule 81 (string -> STRING .)
    BREAK           reduce using rule 81 (string -> STRING .)
    IDENT           reduce using rule 81 (string -> STRING .)
    NOT             reduce using rule 81 (string -> STRING .)
    LPAREN          reduce using rule 81 (string -> STRING .)
    NUMBER          reduce using rule 81 (string -> STRING .)
    STRING          reduce using rule 81 (string -> STRING .)
    TRUE            reduce using rule 81 (string -> STRING .)
    FALSE           reduce using rule 81 (string -> STRING .)
    ELSE            reduce using rule 81 (string -> STRING .)


state 59

    (118) bool_value -> TRUE .

    MUL             reduce using rule 118 (bool_value -> TRUE .)
    DIV             reduce using rule 118 (bool_value -> TRUE .)
    MOD             reduce using rule 118 (bool_value -> TRUE .)
    ADD             reduce using rule 118 (bool_value -> TRUE .)
    SUB             reduce using rule 118 (bool_value -> TRUE .)
    GT              reduce using rule 118 (bool_value -> TRUE .)
    LT              reduce using rule 118 (bool_value -> TRUE .)
    GE              reduce using rule 118 (bool_value -> TRUE .)
    LE              reduce using rule 118 (bool_value -> TRUE .)
    EQUALS          reduce using rule 118 (bool_value -> TRUE .)
    NOTEQUALS       reduce using rule 118 (bool_value -> TRUE .)
    AND             reduce using rule 118 (bool_value -> TRUE .)
    OR              reduce using rule 118 (bool_value -> TRUE .)
    COMMA           reduce using rule 118 (bool_value -> TRUE .)
    SEMICOLON       reduce using rule 118 (bool_value -> TRUE .)
    RPAREN          reduce using rule 118 (bool_value -> TRUE .)
    RBRACKET        reduce using rule 118 (bool_value -> TRUE .)
    RBRACE          reduce using rule 118 (bool_value -> TRUE .)
    LBRACE          reduce using rule 118 (bool_value -> TRUE .)
    IF              reduce using rule 118 (bool_value -> TRUE .)
    FOR             reduce using rule 118 (bool_value -> TRUE .)
    WHILE           reduce using rule 118 (bool_value -> TRUE .)
    DO              reduce using rule 118 (bool_value -> TRUE .)
    RETURN          reduce using rule 118 (bool_value -> TRUE .)
    CONTINUE        reduce using rule 118 (bool_value -> TRUE .)
    BREAK           reduce using rule 118 (bool_value -> TRUE .)
    IDENT           reduce using rule 118 (bool_value -> TRUE .)
    NOT             reduce using rule 118 (bool_value -> TRUE .)
    LPAREN          reduce using rule 118 (bool_value -> TRUE .)
    NUMBER          reduce using rule 118 (bool_value -> TRUE .)
    STRING          reduce using rule 118 (bool_value -> TRUE .)
    TRUE            reduce using rule 118 (bool_value -> TRUE .)
    FALSE           reduce using rule 118 (bool_value -> TRUE .)
    ELSE            reduce using rule 118 (bool_value -> TRUE .)


state 60

    (119) bool_value -> FALSE .

    MUL             reduce using rule 119 (bool_value -> FALSE .)
    DIV             reduce using rule 119 (bool_value -> FALSE .)
    MOD             reduce using rule 119 (bool_value -> FALSE .)
    ADD             reduce using rule 119 (bool_value -> FALSE .)
    SUB             reduce using rule 119 (bool_value -> FALSE .)
    GT              reduce using rule 119 (bool_value -> FALSE .)
    LT              reduce using rule 119 (bool_value -> FALSE .)
    GE              reduce using rule 119 (bool_value -> FALSE .)
    LE              reduce using rule 119 (bool_value -> FALSE .)
    EQUALS          reduce using rule 119 (bool_value -> FALSE .)
    NOTEQUALS       reduce using rule 119 (bool_value -> FALSE .)
    AND             reduce using rule 119 (bool_value -> FALSE .)
    OR              reduce using rule 119 (bool_value -> FALSE .)
    COMMA           reduce using rule 119 (bool_value -> FALSE .)
    SEMICOLON       reduce using rule 119 (bool_value -> FALSE .)
    RPAREN          reduce using rule 119 (bool_value -> FALSE .)
    RBRACKET        reduce using rule 119 (bool_value -> FALSE .)
    RBRACE          reduce using rule 119 (bool_value -> FALSE .)
    LBRACE          reduce using rule 119 (bool_value -> FALSE .)
    IF              reduce using rule 119 (bool_value -> FALSE .)
    FOR             reduce using rule 119 (bool_value -> FALSE .)
    WHILE           reduce using rule 119 (bool_value -> FALSE .)
    DO              reduce using rule 119 (bool_value -> FALSE .)
    RETURN          reduce using rule 119 (bool_value -> FALSE .)
    CONTINUE        reduce using rule 119 (bool_value -> FALSE .)
    BREAK           reduce using rule 119 (bool_value -> FALSE .)
    IDENT           reduce using rule 119 (bool_value -> FALSE .)
    NOT             reduce using rule 119 (bool_value -> FALSE .)
    LPAREN          reduce using rule 119 (bool_value -> FALSE .)
    NUMBER          reduce using rule 119 (bool_value -> FALSE .)
    STRING          reduce using rule 119 (bool_value -> FALSE .)
    TRUE            reduce using rule 119 (bool_value -> FALSE .)
    FALSE           reduce using rule 119 (bool_value -> FALSE .)
    ELSE            reduce using rule 119 (bool_value -> FALSE .)


state 61

    (99) init_array_declarator_list -> init_array_declarator_list COMMA init_array_declarator .

    COMMA           reduce using rule 99 (init_array_declarator_list -> init_array_declarator_list COMMA init_array_declarator .)
    SEMICOLON       reduce using rule 99 (init_array_declarator_list -> init_array_declarator_list COMMA init_array_declarator .)
    RPAREN          reduce using rule 99 (init_array_declarator_list -> init_array_declarator_list COMMA init_array_declarator .)


state 62

    (105) array_initializer -> ident ASSIGN array_value .

    COMMA           reduce using rule 105 (array_initializer -> ident ASSIGN array_value .)
    SEMICOLON       reduce using rule 105 (array_initializer -> ident ASSIGN array_value .)
    RPAREN          reduce using rule 105 (array_initializer -> ident ASSIGN array_value .)


state 63

    (106) array_value -> NEW . type LBRACKET logical_expression RBRACKET
    (107) array_value -> NEW . type BRACKETS LBRACE args_list RBRACE
    (108) array_value -> NEW . type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE
    (95) type -> . IDENT

    IDENT           shift and go to state 34

    type                           shift and go to state 93

state 64

    (87) argument_declaration -> type ident .

    RPAREN          reduce using rule 87 (argument_declaration -> type ident .)
    COMMA           reduce using rule 87 (argument_declaration -> type ident .)


state 65

    (83) function_definition -> type ident LPAREN arguments_declaration_list RPAREN . block
    (16) block -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 95

    block                          shift and go to state 94

state 66

    (86) arguments_declaration_list -> arguments_declaration_list COMMA . argument_declaration
    (87) argument_declaration -> . type ident
    (95) type -> . IDENT

    IDENT           shift and go to state 34

    argument_declaration           shift and go to state 96
    type                           shift and go to state 31

state 67

    (112) get_element -> ident LBRACKET . logical_expression RBRACKET
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    ident                          shift and go to state 92
    logical_expression             shift and go to state 97
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    get_element                    shift and go to state 40

state 68

    (82) call -> ident LPAREN . args_list RPAREN
    (88) args_list -> .
    (89) args_list -> . logical_expression
    (90) args_list -> . args_list COMMA logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    RPAREN          reduce using rule 88 (args_list -> .)
    COMMA           reduce using rule 88 (args_list -> .)
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    ident                          shift and go to state 92
    args_list                      shift and go to state 98
    logical_expression             shift and go to state 99
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    get_element                    shift and go to state 40

state 69

    (80) simple_rvalue -> lvalue ASSIGN . simple_rvalue
    (79) simple_rvalue -> . logical_expression
    (80) simple_rvalue -> . lvalue ASSIGN simple_rvalue
    (34) logical_expression -> . logical_or_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    IDENT           shift and go to state 16
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    lvalue                         shift and go to state 38
    simple_rvalue                  shift and go to state 100
    logical_expression             shift and go to state 37
    logical_or_expression          shift and go to state 39
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 70

    (59) postfix_expression -> lvalue INC_OP .

    MUL             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    DIV             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    MOD             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    ADD             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    SUB             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    GT              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    LT              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    GE              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    LE              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    EQUALS          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    NOTEQUALS       reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    AND             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    OR              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    COMMA           reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    SEMICOLON       reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    RPAREN          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    RBRACKET        reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    RBRACE          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    LBRACE          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    IF              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    FOR             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    WHILE           reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    DO              reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    RETURN          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    CONTINUE        reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    BREAK           reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    IDENT           reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    NOT             reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    LPAREN          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    NUMBER          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    STRING          reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    TRUE            reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    FALSE           reduce using rule 59 (postfix_expression -> lvalue INC_OP .)
    ELSE            reduce using rule 59 (postfix_expression -> lvalue INC_OP .)


state 71

    (60) postfix_expression -> lvalue DEC_OP .

    MUL             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    DIV             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    MOD             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    ADD             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    SUB             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    GT              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    LT              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    GE              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    LE              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    EQUALS          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    NOTEQUALS       reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    AND             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    OR              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    COMMA           reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    SEMICOLON       reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    RPAREN          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    RBRACKET        reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    RBRACE          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    LBRACE          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    IF              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    FOR             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    WHILE           reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    DO              reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    RETURN          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    CONTINUE        reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    BREAK           reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    IDENT           reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    NOT             reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    LPAREN          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    NUMBER          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    STRING          reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    TRUE            reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    FALSE           reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)
    ELSE            reduce using rule 60 (postfix_expression -> lvalue DEC_OP .)


state 72

    (36) logical_or_expression -> logical_or_expression OR . logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_and_expression         shift and go to state 101
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 73

    (38) logical_and_expression -> logical_and_expression AND . equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    equality_expression            shift and go to state 102
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 74

    (40) equality_expression -> equality_expression EQUALS . relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    relational_expression          shift and go to state 103
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 75

    (41) equality_expression -> equality_expression NOTEQUALS . relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    relational_expression          shift and go to state 104
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 76

    (43) relational_expression -> relational_expression GT . additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    additive_expression            shift and go to state 105
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 77

    (44) relational_expression -> relational_expression LT . additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    additive_expression            shift and go to state 106
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 78

    (45) relational_expression -> relational_expression GE . additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    additive_expression            shift and go to state 107
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 79

    (46) relational_expression -> relational_expression LE . additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    additive_expression            shift and go to state 108
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 80

    (48) additive_expression -> additive_expression ADD . multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    multiplicative_expression      shift and go to state 109
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 81

    (49) additive_expression -> additive_expression SUB . multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    multiplicative_expression      shift and go to state 110
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 82

    (51) multiplicative_expression -> multiplicative_expression MUL . unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    unary_expression               shift and go to state 111
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 83

    (52) multiplicative_expression -> multiplicative_expression DIV . unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    unary_expression               shift and go to state 112
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 84

    (53) multiplicative_expression -> multiplicative_expression MOD . unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    unary_expression               shift and go to state 113
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 85

    (57) unary_expression -> ADD group .

    MUL             reduce using rule 57 (unary_expression -> ADD group .)
    DIV             reduce using rule 57 (unary_expression -> ADD group .)
    MOD             reduce using rule 57 (unary_expression -> ADD group .)
    ADD             reduce using rule 57 (unary_expression -> ADD group .)
    SUB             reduce using rule 57 (unary_expression -> ADD group .)
    GT              reduce using rule 57 (unary_expression -> ADD group .)
    LT              reduce using rule 57 (unary_expression -> ADD group .)
    GE              reduce using rule 57 (unary_expression -> ADD group .)
    LE              reduce using rule 57 (unary_expression -> ADD group .)
    EQUALS          reduce using rule 57 (unary_expression -> ADD group .)
    NOTEQUALS       reduce using rule 57 (unary_expression -> ADD group .)
    AND             reduce using rule 57 (unary_expression -> ADD group .)
    OR              reduce using rule 57 (unary_expression -> ADD group .)
    COMMA           reduce using rule 57 (unary_expression -> ADD group .)
    SEMICOLON       reduce using rule 57 (unary_expression -> ADD group .)
    RPAREN          reduce using rule 57 (unary_expression -> ADD group .)
    RBRACKET        reduce using rule 57 (unary_expression -> ADD group .)
    RBRACE          reduce using rule 57 (unary_expression -> ADD group .)
    LBRACE          reduce using rule 57 (unary_expression -> ADD group .)
    IF              reduce using rule 57 (unary_expression -> ADD group .)
    FOR             reduce using rule 57 (unary_expression -> ADD group .)
    WHILE           reduce using rule 57 (unary_expression -> ADD group .)
    DO              reduce using rule 57 (unary_expression -> ADD group .)
    RETURN          reduce using rule 57 (unary_expression -> ADD group .)
    CONTINUE        reduce using rule 57 (unary_expression -> ADD group .)
    BREAK           reduce using rule 57 (unary_expression -> ADD group .)
    IDENT           reduce using rule 57 (unary_expression -> ADD group .)
    NOT             reduce using rule 57 (unary_expression -> ADD group .)
    LPAREN          reduce using rule 57 (unary_expression -> ADD group .)
    NUMBER          reduce using rule 57 (unary_expression -> ADD group .)
    STRING          reduce using rule 57 (unary_expression -> ADD group .)
    TRUE            reduce using rule 57 (unary_expression -> ADD group .)
    FALSE           reduce using rule 57 (unary_expression -> ADD group .)
    ELSE            reduce using rule 57 (unary_expression -> ADD group .)


state 86

    (62) group -> lvalue .

    MUL             reduce using rule 62 (group -> lvalue .)
    DIV             reduce using rule 62 (group -> lvalue .)
    MOD             reduce using rule 62 (group -> lvalue .)
    ADD             reduce using rule 62 (group -> lvalue .)
    SUB             reduce using rule 62 (group -> lvalue .)
    GT              reduce using rule 62 (group -> lvalue .)
    LT              reduce using rule 62 (group -> lvalue .)
    GE              reduce using rule 62 (group -> lvalue .)
    LE              reduce using rule 62 (group -> lvalue .)
    EQUALS          reduce using rule 62 (group -> lvalue .)
    NOTEQUALS       reduce using rule 62 (group -> lvalue .)
    AND             reduce using rule 62 (group -> lvalue .)
    OR              reduce using rule 62 (group -> lvalue .)
    COMMA           reduce using rule 62 (group -> lvalue .)
    SEMICOLON       reduce using rule 62 (group -> lvalue .)
    RPAREN          reduce using rule 62 (group -> lvalue .)
    RBRACKET        reduce using rule 62 (group -> lvalue .)
    RBRACE          reduce using rule 62 (group -> lvalue .)
    LBRACE          reduce using rule 62 (group -> lvalue .)
    IF              reduce using rule 62 (group -> lvalue .)
    FOR             reduce using rule 62 (group -> lvalue .)
    WHILE           reduce using rule 62 (group -> lvalue .)
    DO              reduce using rule 62 (group -> lvalue .)
    RETURN          reduce using rule 62 (group -> lvalue .)
    CONTINUE        reduce using rule 62 (group -> lvalue .)
    BREAK           reduce using rule 62 (group -> lvalue .)
    IDENT           reduce using rule 62 (group -> lvalue .)
    NOT             reduce using rule 62 (group -> lvalue .)
    LPAREN          reduce using rule 62 (group -> lvalue .)
    NUMBER          reduce using rule 62 (group -> lvalue .)
    STRING          reduce using rule 62 (group -> lvalue .)
    TRUE            reduce using rule 62 (group -> lvalue .)
    FALSE           reduce using rule 62 (group -> lvalue .)
    ELSE            reduce using rule 62 (group -> lvalue .)


state 87

    (82) call -> ident . LPAREN args_list RPAREN
    (110) lvalue -> ident .
    (112) get_element -> ident . LBRACKET logical_expression RBRACKET

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 68
    MUL             reduce using rule 110 (lvalue -> ident .)
    DIV             reduce using rule 110 (lvalue -> ident .)
    MOD             reduce using rule 110 (lvalue -> ident .)
    ADD             reduce using rule 110 (lvalue -> ident .)
    SUB             reduce using rule 110 (lvalue -> ident .)
    GT              reduce using rule 110 (lvalue -> ident .)
    LT              reduce using rule 110 (lvalue -> ident .)
    GE              reduce using rule 110 (lvalue -> ident .)
    LE              reduce using rule 110 (lvalue -> ident .)
    EQUALS          reduce using rule 110 (lvalue -> ident .)
    NOTEQUALS       reduce using rule 110 (lvalue -> ident .)
    AND             reduce using rule 110 (lvalue -> ident .)
    OR              reduce using rule 110 (lvalue -> ident .)
    COMMA           reduce using rule 110 (lvalue -> ident .)
    SEMICOLON       reduce using rule 110 (lvalue -> ident .)
    RPAREN          reduce using rule 110 (lvalue -> ident .)
    RBRACKET        reduce using rule 110 (lvalue -> ident .)
    RBRACE          reduce using rule 110 (lvalue -> ident .)
    LBRACE          reduce using rule 110 (lvalue -> ident .)
    IF              reduce using rule 110 (lvalue -> ident .)
    FOR             reduce using rule 110 (lvalue -> ident .)
    WHILE           reduce using rule 110 (lvalue -> ident .)
    DO              reduce using rule 110 (lvalue -> ident .)
    RETURN          reduce using rule 110 (lvalue -> ident .)
    CONTINUE        reduce using rule 110 (lvalue -> ident .)
    BREAK           reduce using rule 110 (lvalue -> ident .)
    IDENT           reduce using rule 110 (lvalue -> ident .)
    NOT             reduce using rule 110 (lvalue -> ident .)
    NUMBER          reduce using rule 110 (lvalue -> ident .)
    STRING          reduce using rule 110 (lvalue -> ident .)
    TRUE            reduce using rule 110 (lvalue -> ident .)
    FALSE           reduce using rule 110 (lvalue -> ident .)
    ELSE            reduce using rule 110 (lvalue -> ident .)
    LBRACKET        shift and go to state 67

  ! LPAREN          [ reduce using rule 110 (lvalue -> ident .) ]


state 88

    (56) unary_expression -> SUB group .

    MUL             reduce using rule 56 (unary_expression -> SUB group .)
    DIV             reduce using rule 56 (unary_expression -> SUB group .)
    MOD             reduce using rule 56 (unary_expression -> SUB group .)
    ADD             reduce using rule 56 (unary_expression -> SUB group .)
    SUB             reduce using rule 56 (unary_expression -> SUB group .)
    GT              reduce using rule 56 (unary_expression -> SUB group .)
    LT              reduce using rule 56 (unary_expression -> SUB group .)
    GE              reduce using rule 56 (unary_expression -> SUB group .)
    LE              reduce using rule 56 (unary_expression -> SUB group .)
    EQUALS          reduce using rule 56 (unary_expression -> SUB group .)
    NOTEQUALS       reduce using rule 56 (unary_expression -> SUB group .)
    AND             reduce using rule 56 (unary_expression -> SUB group .)
    OR              reduce using rule 56 (unary_expression -> SUB group .)
    COMMA           reduce using rule 56 (unary_expression -> SUB group .)
    SEMICOLON       reduce using rule 56 (unary_expression -> SUB group .)
    RPAREN          reduce using rule 56 (unary_expression -> SUB group .)
    RBRACKET        reduce using rule 56 (unary_expression -> SUB group .)
    RBRACE          reduce using rule 56 (unary_expression -> SUB group .)
    LBRACE          reduce using rule 56 (unary_expression -> SUB group .)
    IF              reduce using rule 56 (unary_expression -> SUB group .)
    FOR             reduce using rule 56 (unary_expression -> SUB group .)
    WHILE           reduce using rule 56 (unary_expression -> SUB group .)
    DO              reduce using rule 56 (unary_expression -> SUB group .)
    RETURN          reduce using rule 56 (unary_expression -> SUB group .)
    CONTINUE        reduce using rule 56 (unary_expression -> SUB group .)
    BREAK           reduce using rule 56 (unary_expression -> SUB group .)
    IDENT           reduce using rule 56 (unary_expression -> SUB group .)
    NOT             reduce using rule 56 (unary_expression -> SUB group .)
    LPAREN          reduce using rule 56 (unary_expression -> SUB group .)
    NUMBER          reduce using rule 56 (unary_expression -> SUB group .)
    STRING          reduce using rule 56 (unary_expression -> SUB group .)
    TRUE            reduce using rule 56 (unary_expression -> SUB group .)
    FALSE           reduce using rule 56 (unary_expression -> SUB group .)
    ELSE            reduce using rule 56 (unary_expression -> SUB group .)


state 89

    (55) unary_expression -> NOT group .

    MUL             reduce using rule 55 (unary_expression -> NOT group .)
    DIV             reduce using rule 55 (unary_expression -> NOT group .)
    MOD             reduce using rule 55 (unary_expression -> NOT group .)
    ADD             reduce using rule 55 (unary_expression -> NOT group .)
    SUB             reduce using rule 55 (unary_expression -> NOT group .)
    GT              reduce using rule 55 (unary_expression -> NOT group .)
    LT              reduce using rule 55 (unary_expression -> NOT group .)
    GE              reduce using rule 55 (unary_expression -> NOT group .)
    LE              reduce using rule 55 (unary_expression -> NOT group .)
    EQUALS          reduce using rule 55 (unary_expression -> NOT group .)
    NOTEQUALS       reduce using rule 55 (unary_expression -> NOT group .)
    AND             reduce using rule 55 (unary_expression -> NOT group .)
    OR              reduce using rule 55 (unary_expression -> NOT group .)
    COMMA           reduce using rule 55 (unary_expression -> NOT group .)
    SEMICOLON       reduce using rule 55 (unary_expression -> NOT group .)
    RPAREN          reduce using rule 55 (unary_expression -> NOT group .)
    RBRACKET        reduce using rule 55 (unary_expression -> NOT group .)
    RBRACE          reduce using rule 55 (unary_expression -> NOT group .)
    LBRACE          reduce using rule 55 (unary_expression -> NOT group .)
    IF              reduce using rule 55 (unary_expression -> NOT group .)
    FOR             reduce using rule 55 (unary_expression -> NOT group .)
    WHILE           reduce using rule 55 (unary_expression -> NOT group .)
    DO              reduce using rule 55 (unary_expression -> NOT group .)
    RETURN          reduce using rule 55 (unary_expression -> NOT group .)
    CONTINUE        reduce using rule 55 (unary_expression -> NOT group .)
    BREAK           reduce using rule 55 (unary_expression -> NOT group .)
    IDENT           reduce using rule 55 (unary_expression -> NOT group .)
    NOT             reduce using rule 55 (unary_expression -> NOT group .)
    LPAREN          reduce using rule 55 (unary_expression -> NOT group .)
    NUMBER          reduce using rule 55 (unary_expression -> NOT group .)
    STRING          reduce using rule 55 (unary_expression -> NOT group .)
    TRUE            reduce using rule 55 (unary_expression -> NOT group .)
    FALSE           reduce using rule 55 (unary_expression -> NOT group .)
    ELSE            reduce using rule 55 (unary_expression -> NOT group .)


state 90

    (63) group -> LPAREN logical_expression . RPAREN

    RPAREN          shift and go to state 114


state 91

    (59) postfix_expression -> lvalue . INC_OP
    (60) postfix_expression -> lvalue . DEC_OP
    (62) group -> lvalue .

    INC_OP          shift and go to state 70
    DEC_OP          shift and go to state 71
    MUL             reduce using rule 62 (group -> lvalue .)
    DIV             reduce using rule 62 (group -> lvalue .)
    MOD             reduce using rule 62 (group -> lvalue .)
    ADD             reduce using rule 62 (group -> lvalue .)
    SUB             reduce using rule 62 (group -> lvalue .)
    GT              reduce using rule 62 (group -> lvalue .)
    LT              reduce using rule 62 (group -> lvalue .)
    GE              reduce using rule 62 (group -> lvalue .)
    LE              reduce using rule 62 (group -> lvalue .)
    EQUALS          reduce using rule 62 (group -> lvalue .)
    NOTEQUALS       reduce using rule 62 (group -> lvalue .)
    AND             reduce using rule 62 (group -> lvalue .)
    OR              reduce using rule 62 (group -> lvalue .)
    RPAREN          reduce using rule 62 (group -> lvalue .)
    RBRACKET        reduce using rule 62 (group -> lvalue .)
    COMMA           reduce using rule 62 (group -> lvalue .)
    SEMICOLON       reduce using rule 62 (group -> lvalue .)
    RBRACE          reduce using rule 62 (group -> lvalue .)
    LBRACE          reduce using rule 62 (group -> lvalue .)
    IF              reduce using rule 62 (group -> lvalue .)
    FOR             reduce using rule 62 (group -> lvalue .)
    WHILE           reduce using rule 62 (group -> lvalue .)
    DO              reduce using rule 62 (group -> lvalue .)
    RETURN          reduce using rule 62 (group -> lvalue .)
    CONTINUE        reduce using rule 62 (group -> lvalue .)
    BREAK           reduce using rule 62 (group -> lvalue .)
    IDENT           reduce using rule 62 (group -> lvalue .)
    NOT             reduce using rule 62 (group -> lvalue .)
    LPAREN          reduce using rule 62 (group -> lvalue .)
    NUMBER          reduce using rule 62 (group -> lvalue .)
    STRING          reduce using rule 62 (group -> lvalue .)
    TRUE            reduce using rule 62 (group -> lvalue .)
    FALSE           reduce using rule 62 (group -> lvalue .)
    ELSE            reduce using rule 62 (group -> lvalue .)


state 92

    (110) lvalue -> ident .
    (82) call -> ident . LPAREN args_list RPAREN
    (112) get_element -> ident . LBRACKET logical_expression RBRACKET

  ! shift/reduce conflict for LPAREN resolved as shift
    INC_OP          reduce using rule 110 (lvalue -> ident .)
    DEC_OP          reduce using rule 110 (lvalue -> ident .)
    MUL             reduce using rule 110 (lvalue -> ident .)
    DIV             reduce using rule 110 (lvalue -> ident .)
    MOD             reduce using rule 110 (lvalue -> ident .)
    ADD             reduce using rule 110 (lvalue -> ident .)
    SUB             reduce using rule 110 (lvalue -> ident .)
    GT              reduce using rule 110 (lvalue -> ident .)
    LT              reduce using rule 110 (lvalue -> ident .)
    GE              reduce using rule 110 (lvalue -> ident .)
    LE              reduce using rule 110 (lvalue -> ident .)
    EQUALS          reduce using rule 110 (lvalue -> ident .)
    NOTEQUALS       reduce using rule 110 (lvalue -> ident .)
    AND             reduce using rule 110 (lvalue -> ident .)
    OR              reduce using rule 110 (lvalue -> ident .)
    RPAREN          reduce using rule 110 (lvalue -> ident .)
    RBRACKET        reduce using rule 110 (lvalue -> ident .)
    COMMA           reduce using rule 110 (lvalue -> ident .)
    SEMICOLON       reduce using rule 110 (lvalue -> ident .)
    RBRACE          reduce using rule 110 (lvalue -> ident .)
    LBRACE          reduce using rule 110 (lvalue -> ident .)
    IF              reduce using rule 110 (lvalue -> ident .)
    FOR             reduce using rule 110 (lvalue -> ident .)
    WHILE           reduce using rule 110 (lvalue -> ident .)
    DO              reduce using rule 110 (lvalue -> ident .)
    RETURN          reduce using rule 110 (lvalue -> ident .)
    CONTINUE        reduce using rule 110 (lvalue -> ident .)
    BREAK           reduce using rule 110 (lvalue -> ident .)
    IDENT           reduce using rule 110 (lvalue -> ident .)
    NOT             reduce using rule 110 (lvalue -> ident .)
    NUMBER          reduce using rule 110 (lvalue -> ident .)
    STRING          reduce using rule 110 (lvalue -> ident .)
    TRUE            reduce using rule 110 (lvalue -> ident .)
    FALSE           reduce using rule 110 (lvalue -> ident .)
    ELSE            reduce using rule 110 (lvalue -> ident .)
    LPAREN          shift and go to state 68
    LBRACKET        shift and go to state 67

  ! LPAREN          [ reduce using rule 110 (lvalue -> ident .) ]


state 93

    (106) array_value -> NEW type . LBRACKET logical_expression RBRACKET
    (107) array_value -> NEW type . BRACKETS LBRACE args_list RBRACE
    (108) array_value -> NEW type . LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE

    LBRACKET        shift and go to state 115
    BRACKETS        shift and go to state 116


state 94

    (83) function_definition -> type ident LPAREN arguments_declaration_list RPAREN block .

    SEMICOLON       reduce using rule 83 (function_definition -> type ident LPAREN arguments_declaration_list RPAREN block .)
    IDENT           reduce using rule 83 (function_definition -> type ident LPAREN arguments_declaration_list RPAREN block .)
    $end            reduce using rule 83 (function_definition -> type ident LPAREN arguments_declaration_list RPAREN block .)


state 95

    (16) block -> LBRACE . statement_list RBRACE
    (7) statement_list -> .
    (8) statement_list -> . statement_list statement

    RBRACE          reduce using rule 7 (statement_list -> .)
    LBRACE          reduce using rule 7 (statement_list -> .)
    SEMICOLON       reduce using rule 7 (statement_list -> .)
    IF              reduce using rule 7 (statement_list -> .)
    FOR             reduce using rule 7 (statement_list -> .)
    WHILE           reduce using rule 7 (statement_list -> .)
    DO              reduce using rule 7 (statement_list -> .)
    RETURN          reduce using rule 7 (statement_list -> .)
    CONTINUE        reduce using rule 7 (statement_list -> .)
    BREAK           reduce using rule 7 (statement_list -> .)
    IDENT           reduce using rule 7 (statement_list -> .)
    NOT             reduce using rule 7 (statement_list -> .)
    SUB             reduce using rule 7 (statement_list -> .)
    ADD             reduce using rule 7 (statement_list -> .)
    LPAREN          reduce using rule 7 (statement_list -> .)
    NUMBER          reduce using rule 7 (statement_list -> .)
    STRING          reduce using rule 7 (statement_list -> .)
    TRUE            reduce using rule 7 (statement_list -> .)
    FALSE           reduce using rule 7 (statement_list -> .)

    statement_list                 shift and go to state 117

state 96

    (86) arguments_declaration_list -> arguments_declaration_list COMMA argument_declaration .

    RPAREN          reduce using rule 86 (arguments_declaration_list -> arguments_declaration_list COMMA argument_declaration .)
    COMMA           reduce using rule 86 (arguments_declaration_list -> arguments_declaration_list COMMA argument_declaration .)


state 97

    (112) get_element -> ident LBRACKET logical_expression . RBRACKET

    RBRACKET        shift and go to state 118


state 98

    (82) call -> ident LPAREN args_list . RPAREN
    (90) args_list -> args_list . COMMA logical_expression

    RPAREN          shift and go to state 119
    COMMA           shift and go to state 120


state 99

    (89) args_list -> logical_expression .

    RPAREN          reduce using rule 89 (args_list -> logical_expression .)
    COMMA           reduce using rule 89 (args_list -> logical_expression .)
    RBRACE          reduce using rule 89 (args_list -> logical_expression .)


state 100

    (80) simple_rvalue -> lvalue ASSIGN simple_rvalue .

    COMMA           reduce using rule 80 (simple_rvalue -> lvalue ASSIGN simple_rvalue .)
    SEMICOLON       reduce using rule 80 (simple_rvalue -> lvalue ASSIGN simple_rvalue .)
    RPAREN          reduce using rule 80 (simple_rvalue -> lvalue ASSIGN simple_rvalue .)


state 101

    (36) logical_or_expression -> logical_or_expression OR logical_and_expression .
    (38) logical_and_expression -> logical_and_expression . AND equality_expression

    OR              reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    COMMA           reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    SEMICOLON       reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    RPAREN          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    RBRACKET        reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    RBRACE          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    LBRACE          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    IF              reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    FOR             reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    WHILE           reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    DO              reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    RETURN          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    CONTINUE        reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    BREAK           reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    IDENT           reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    NOT             reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    SUB             reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    ADD             reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    LPAREN          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    NUMBER          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    STRING          reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    TRUE            reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    FALSE           reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    ELSE            reduce using rule 36 (logical_or_expression -> logical_or_expression OR logical_and_expression .)
    AND             shift and go to state 73


state 102

    (38) logical_and_expression -> logical_and_expression AND equality_expression .
    (40) equality_expression -> equality_expression . EQUALS relational_expression
    (41) equality_expression -> equality_expression . NOTEQUALS relational_expression

    AND             reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    OR              reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    COMMA           reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    SEMICOLON       reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    RPAREN          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    RBRACKET        reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    RBRACE          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    LBRACE          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    IF              reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    FOR             reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    WHILE           reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    DO              reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    RETURN          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    CONTINUE        reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    BREAK           reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    IDENT           reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    NOT             reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    SUB             reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    ADD             reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    LPAREN          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    NUMBER          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    STRING          reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    TRUE            reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    FALSE           reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    ELSE            reduce using rule 38 (logical_and_expression -> logical_and_expression AND equality_expression .)
    EQUALS          shift and go to state 74
    NOTEQUALS       shift and go to state 75


state 103

    (40) equality_expression -> equality_expression EQUALS relational_expression .
    (43) relational_expression -> relational_expression . GT additive_expression
    (44) relational_expression -> relational_expression . LT additive_expression
    (45) relational_expression -> relational_expression . GE additive_expression
    (46) relational_expression -> relational_expression . LE additive_expression

    EQUALS          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    NOTEQUALS       reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    AND             reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    OR              reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    COMMA           reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    SEMICOLON       reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    RPAREN          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    RBRACKET        reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    RBRACE          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    LBRACE          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    IF              reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    FOR             reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    WHILE           reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    DO              reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    RETURN          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    CONTINUE        reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    BREAK           reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    IDENT           reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    NOT             reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    SUB             reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    ADD             reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    LPAREN          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    NUMBER          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    STRING          reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    TRUE            reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    FALSE           reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    ELSE            reduce using rule 40 (equality_expression -> equality_expression EQUALS relational_expression .)
    GT              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79


state 104

    (41) equality_expression -> equality_expression NOTEQUALS relational_expression .
    (43) relational_expression -> relational_expression . GT additive_expression
    (44) relational_expression -> relational_expression . LT additive_expression
    (45) relational_expression -> relational_expression . GE additive_expression
    (46) relational_expression -> relational_expression . LE additive_expression

    EQUALS          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    NOTEQUALS       reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    AND             reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    OR              reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    COMMA           reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    SEMICOLON       reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    RPAREN          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    RBRACKET        reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    RBRACE          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    LBRACE          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    IF              reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    FOR             reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    WHILE           reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    DO              reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    RETURN          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    CONTINUE        reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    BREAK           reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    IDENT           reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    NOT             reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    SUB             reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    ADD             reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    LPAREN          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    NUMBER          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    STRING          reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    TRUE            reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    FALSE           reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    ELSE            reduce using rule 41 (equality_expression -> equality_expression NOTEQUALS relational_expression .)
    GT              shift and go to state 76
    LT              shift and go to state 77
    GE              shift and go to state 78
    LE              shift and go to state 79


state 105

    (43) relational_expression -> relational_expression GT additive_expression .
    (48) additive_expression -> additive_expression . ADD multiplicative_expression
    (49) additive_expression -> additive_expression . SUB multiplicative_expression

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    GT              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    LT              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    GE              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    LE              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    EQUALS          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    NOTEQUALS       reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    AND             reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    OR              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    COMMA           reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    SEMICOLON       reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    RPAREN          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    RBRACKET        reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    RBRACE          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    LBRACE          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    IF              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    FOR             reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    WHILE           reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    DO              reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    RETURN          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    CONTINUE        reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    BREAK           reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    IDENT           reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    NOT             reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    LPAREN          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    NUMBER          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    STRING          reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    TRUE            reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    FALSE           reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    ELSE            reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .)
    ADD             shift and go to state 80
    SUB             shift and go to state 81

  ! SUB             [ reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .) ]
  ! ADD             [ reduce using rule 43 (relational_expression -> relational_expression GT additive_expression .) ]


state 106

    (44) relational_expression -> relational_expression LT additive_expression .
    (48) additive_expression -> additive_expression . ADD multiplicative_expression
    (49) additive_expression -> additive_expression . SUB multiplicative_expression

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    GT              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    LT              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    GE              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    LE              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    EQUALS          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    NOTEQUALS       reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    AND             reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    OR              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    COMMA           reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    SEMICOLON       reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    RPAREN          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    RBRACKET        reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    RBRACE          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    LBRACE          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    IF              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    FOR             reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    WHILE           reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    DO              reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    RETURN          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    CONTINUE        reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    BREAK           reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    IDENT           reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    NOT             reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    LPAREN          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    NUMBER          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    STRING          reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    TRUE            reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    FALSE           reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    ELSE            reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .)
    ADD             shift and go to state 80
    SUB             shift and go to state 81

  ! SUB             [ reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .) ]
  ! ADD             [ reduce using rule 44 (relational_expression -> relational_expression LT additive_expression .) ]


state 107

    (45) relational_expression -> relational_expression GE additive_expression .
    (48) additive_expression -> additive_expression . ADD multiplicative_expression
    (49) additive_expression -> additive_expression . SUB multiplicative_expression

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    GT              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    LT              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    GE              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    LE              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    EQUALS          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    NOTEQUALS       reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    AND             reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    OR              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    COMMA           reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    SEMICOLON       reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    RPAREN          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    RBRACKET        reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    RBRACE          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    LBRACE          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    IF              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    FOR             reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    WHILE           reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    DO              reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    RETURN          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    CONTINUE        reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    BREAK           reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    IDENT           reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    NOT             reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    LPAREN          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    NUMBER          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    STRING          reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    TRUE            reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    FALSE           reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    ELSE            reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .)
    ADD             shift and go to state 80
    SUB             shift and go to state 81

  ! SUB             [ reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .) ]
  ! ADD             [ reduce using rule 45 (relational_expression -> relational_expression GE additive_expression .) ]


state 108

    (46) relational_expression -> relational_expression LE additive_expression .
    (48) additive_expression -> additive_expression . ADD multiplicative_expression
    (49) additive_expression -> additive_expression . SUB multiplicative_expression

  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
    GT              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    LT              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    GE              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    LE              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    EQUALS          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    NOTEQUALS       reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    AND             reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    OR              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    COMMA           reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    SEMICOLON       reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    RPAREN          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    RBRACKET        reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    RBRACE          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    LBRACE          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    IF              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    FOR             reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    WHILE           reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    DO              reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    RETURN          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    CONTINUE        reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    BREAK           reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    IDENT           reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    NOT             reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    LPAREN          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    NUMBER          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    STRING          reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    TRUE            reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    FALSE           reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    ELSE            reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .)
    ADD             shift and go to state 80
    SUB             shift and go to state 81

  ! SUB             [ reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .) ]
  ! ADD             [ reduce using rule 46 (relational_expression -> relational_expression LE additive_expression .) ]


state 109

    (48) additive_expression -> additive_expression ADD multiplicative_expression .
    (51) multiplicative_expression -> multiplicative_expression . MUL unary_expression
    (52) multiplicative_expression -> multiplicative_expression . DIV unary_expression
    (53) multiplicative_expression -> multiplicative_expression . MOD unary_expression

    ADD             reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    SUB             reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    GT              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    LT              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    GE              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    LE              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    EQUALS          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    NOTEQUALS       reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    AND             reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    OR              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    COMMA           reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    SEMICOLON       reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    RPAREN          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    RBRACKET        reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    RBRACE          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    LBRACE          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    IF              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    FOR             reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    WHILE           reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    DO              reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    RETURN          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    CONTINUE        reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    BREAK           reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    IDENT           reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    NOT             reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    LPAREN          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    NUMBER          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    STRING          reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    TRUE            reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    FALSE           reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    ELSE            reduce using rule 48 (additive_expression -> additive_expression ADD multiplicative_expression .)
    MUL             shift and go to state 82
    DIV             shift and go to state 83
    MOD             shift and go to state 84


state 110

    (49) additive_expression -> additive_expression SUB multiplicative_expression .
    (51) multiplicative_expression -> multiplicative_expression . MUL unary_expression
    (52) multiplicative_expression -> multiplicative_expression . DIV unary_expression
    (53) multiplicative_expression -> multiplicative_expression . MOD unary_expression

    ADD             reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    SUB             reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    GT              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    LT              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    GE              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    LE              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    EQUALS          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    NOTEQUALS       reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    AND             reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    OR              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    COMMA           reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    SEMICOLON       reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    RPAREN          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    RBRACKET        reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    RBRACE          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    LBRACE          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    IF              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    FOR             reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    WHILE           reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    DO              reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    RETURN          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    CONTINUE        reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    BREAK           reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    IDENT           reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    NOT             reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    LPAREN          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    NUMBER          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    STRING          reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    TRUE            reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    FALSE           reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    ELSE            reduce using rule 49 (additive_expression -> additive_expression SUB multiplicative_expression .)
    MUL             shift and go to state 82
    DIV             shift and go to state 83
    MOD             shift and go to state 84


state 111

    (51) multiplicative_expression -> multiplicative_expression MUL unary_expression .

    MUL             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    DIV             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    MOD             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    ADD             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    SUB             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    GT              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    LT              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    GE              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    LE              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    EQUALS          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    NOTEQUALS       reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    AND             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    OR              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    COMMA           reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    SEMICOLON       reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    RPAREN          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    RBRACKET        reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    RBRACE          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    LBRACE          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    IF              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    FOR             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    WHILE           reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    DO              reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    RETURN          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    CONTINUE        reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    BREAK           reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    IDENT           reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    NOT             reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    LPAREN          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    NUMBER          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    STRING          reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    TRUE            reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    FALSE           reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)
    ELSE            reduce using rule 51 (multiplicative_expression -> multiplicative_expression MUL unary_expression .)


state 112

    (52) multiplicative_expression -> multiplicative_expression DIV unary_expression .

    MUL             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    DIV             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    MOD             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    ADD             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    SUB             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    GT              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    LT              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    GE              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    LE              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    EQUALS          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    NOTEQUALS       reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    AND             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    OR              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    COMMA           reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    SEMICOLON       reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    RPAREN          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    RBRACKET        reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    RBRACE          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    LBRACE          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    IF              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    FOR             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    WHILE           reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    DO              reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    RETURN          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    CONTINUE        reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    BREAK           reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    IDENT           reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    NOT             reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    LPAREN          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    NUMBER          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    STRING          reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    TRUE            reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    FALSE           reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)
    ELSE            reduce using rule 52 (multiplicative_expression -> multiplicative_expression DIV unary_expression .)


state 113

    (53) multiplicative_expression -> multiplicative_expression MOD unary_expression .

    MUL             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    DIV             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    MOD             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    ADD             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    SUB             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    GT              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    LT              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    GE              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    LE              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    EQUALS          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    NOTEQUALS       reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    AND             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    OR              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    COMMA           reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    SEMICOLON       reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    RPAREN          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    RBRACKET        reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    RBRACE          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    LBRACE          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    IF              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    FOR             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    WHILE           reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    DO              reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    RETURN          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    CONTINUE        reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    BREAK           reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    IDENT           reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    NOT             reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    LPAREN          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    NUMBER          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    STRING          reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    TRUE            reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    FALSE           reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)
    ELSE            reduce using rule 53 (multiplicative_expression -> multiplicative_expression MOD unary_expression .)


state 114

    (63) group -> LPAREN logical_expression RPAREN .

    MUL             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    DIV             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    MOD             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    ADD             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    SUB             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    GT              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    LT              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    GE              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    LE              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    EQUALS          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    NOTEQUALS       reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    AND             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    COMMA           reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    RPAREN          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    RBRACKET        reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    RBRACE          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    LBRACE          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    IF              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    FOR             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    WHILE           reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    DO              reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    RETURN          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    CONTINUE        reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    BREAK           reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    IDENT           reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    NOT             reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    LPAREN          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    NUMBER          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    STRING          reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    TRUE            reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    FALSE           reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)
    ELSE            reduce using rule 63 (group -> LPAREN logical_expression RPAREN .)


state 115

    (106) array_value -> NEW type LBRACKET . logical_expression RBRACKET
    (108) array_value -> NEW type LBRACKET . logical_expression RBRACKET LBRACE args_list RBRACE
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 121
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 116

    (107) array_value -> NEW type BRACKETS . LBRACE args_list RBRACE

    LBRACE          shift and go to state 122


state 117

    (16) block -> LBRACE statement_list . RBRACE
    (8) statement_list -> statement_list . statement
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    RBRACE          shift and go to state 123
    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    statement                      shift and go to state 124
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    semicolons                     shift and go to state 130
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    logical_expression             shift and go to state 139
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 118

    (112) get_element -> ident LBRACKET logical_expression RBRACKET .

    ASSIGN          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    INC_OP          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    DEC_OP          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    MUL             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    DIV             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    MOD             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    ADD             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    SUB             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    GT              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    LT              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    GE              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    LE              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    EQUALS          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    NOTEQUALS       reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    AND             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    OR              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    COMMA           reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    SEMICOLON       reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    RPAREN          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    RBRACKET        reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    RBRACE          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    LBRACE          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    IF              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    FOR             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    WHILE           reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    DO              reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    RETURN          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    CONTINUE        reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    BREAK           reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    IDENT           reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    NOT             reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    LPAREN          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    NUMBER          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    STRING          reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    TRUE            reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    FALSE           reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    ELSE            reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    ADD_ASSIGN      reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    SUB_ASSIGN      reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    MUL_ASSIGN      reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    DIV_ASSIGN      reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)
    MOD_ASSIGN      reduce using rule 112 (get_element -> ident LBRACKET logical_expression RBRACKET .)


state 119

    (82) call -> ident LPAREN args_list RPAREN .

    MUL             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    DIV             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    MOD             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    ADD             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    SUB             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    GT              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    LT              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    GE              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    LE              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    EQUALS          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    NOTEQUALS       reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    AND             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    OR              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    COMMA           reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    SEMICOLON       reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    RPAREN          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    RBRACKET        reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    RBRACE          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    LBRACE          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    IF              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    FOR             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    WHILE           reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    DO              reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    RETURN          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    CONTINUE        reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    BREAK           reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    IDENT           reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    NOT             reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    LPAREN          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    NUMBER          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    STRING          reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    TRUE            reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    FALSE           reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)
    ELSE            reduce using rule 82 (call -> ident LPAREN args_list RPAREN .)


state 120

    (90) args_list -> args_list COMMA . logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 152
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 121

    (106) array_value -> NEW type LBRACKET logical_expression . RBRACKET
    (108) array_value -> NEW type LBRACKET logical_expression . RBRACKET LBRACE args_list RBRACE

    RBRACKET        shift and go to state 153


state 122

    (107) array_value -> NEW type BRACKETS LBRACE . args_list RBRACE
    (88) args_list -> .
    (89) args_list -> . logical_expression
    (90) args_list -> . args_list COMMA logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    RBRACE          reduce using rule 88 (args_list -> .)
    COMMA           reduce using rule 88 (args_list -> .)
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    args_list                      shift and go to state 154
    logical_expression             shift and go to state 99
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 123

    (16) block -> LBRACE statement_list RBRACE .

    SEMICOLON       reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    IDENT           reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    DO              reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    SUB             reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    ADD             reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    STRING          reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 16 (block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 16 (block -> LBRACE statement_list RBRACE .)


state 124

    (8) statement_list -> statement_list statement .

    RBRACE          reduce using rule 8 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 8 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 8 (statement_list -> statement_list statement .)
    IF              reduce using rule 8 (statement_list -> statement_list statement .)
    FOR             reduce using rule 8 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 8 (statement_list -> statement_list statement .)
    DO              reduce using rule 8 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 8 (statement_list -> statement_list statement .)
    CONTINUE        reduce using rule 8 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 8 (statement_list -> statement_list statement .)
    IDENT           reduce using rule 8 (statement_list -> statement_list statement .)
    NOT             reduce using rule 8 (statement_list -> statement_list statement .)
    SUB             reduce using rule 8 (statement_list -> statement_list statement .)
    ADD             reduce using rule 8 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 8 (statement_list -> statement_list statement .)
    NUMBER          reduce using rule 8 (statement_list -> statement_list statement .)
    STRING          reduce using rule 8 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 8 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 8 (statement_list -> statement_list statement .)


state 125

    (9) statement -> simple_statement .

    RBRACE          reduce using rule 9 (statement -> simple_statement .)
    LBRACE          reduce using rule 9 (statement -> simple_statement .)
    SEMICOLON       reduce using rule 9 (statement -> simple_statement .)
    IF              reduce using rule 9 (statement -> simple_statement .)
    FOR             reduce using rule 9 (statement -> simple_statement .)
    WHILE           reduce using rule 9 (statement -> simple_statement .)
    DO              reduce using rule 9 (statement -> simple_statement .)
    RETURN          reduce using rule 9 (statement -> simple_statement .)
    CONTINUE        reduce using rule 9 (statement -> simple_statement .)
    BREAK           reduce using rule 9 (statement -> simple_statement .)
    IDENT           reduce using rule 9 (statement -> simple_statement .)
    NOT             reduce using rule 9 (statement -> simple_statement .)
    SUB             reduce using rule 9 (statement -> simple_statement .)
    ADD             reduce using rule 9 (statement -> simple_statement .)
    LPAREN          reduce using rule 9 (statement -> simple_statement .)
    NUMBER          reduce using rule 9 (statement -> simple_statement .)
    STRING          reduce using rule 9 (statement -> simple_statement .)
    TRUE            reduce using rule 9 (statement -> simple_statement .)
    FALSE           reduce using rule 9 (statement -> simple_statement .)
    ELSE            reduce using rule 9 (statement -> simple_statement .)


state 126

    (10) statement -> block .

    RBRACE          reduce using rule 10 (statement -> block .)
    LBRACE          reduce using rule 10 (statement -> block .)
    SEMICOLON       reduce using rule 10 (statement -> block .)
    IF              reduce using rule 10 (statement -> block .)
    FOR             reduce using rule 10 (statement -> block .)
    WHILE           reduce using rule 10 (statement -> block .)
    DO              reduce using rule 10 (statement -> block .)
    RETURN          reduce using rule 10 (statement -> block .)
    CONTINUE        reduce using rule 10 (statement -> block .)
    BREAK           reduce using rule 10 (statement -> block .)
    IDENT           reduce using rule 10 (statement -> block .)
    NOT             reduce using rule 10 (statement -> block .)
    SUB             reduce using rule 10 (statement -> block .)
    ADD             reduce using rule 10 (statement -> block .)
    LPAREN          reduce using rule 10 (statement -> block .)
    NUMBER          reduce using rule 10 (statement -> block .)
    STRING          reduce using rule 10 (statement -> block .)
    TRUE            reduce using rule 10 (statement -> block .)
    FALSE           reduce using rule 10 (statement -> block .)
    ELSE            reduce using rule 10 (statement -> block .)


state 127

    (11) statement -> selection_statement .

    RBRACE          reduce using rule 11 (statement -> selection_statement .)
    LBRACE          reduce using rule 11 (statement -> selection_statement .)
    SEMICOLON       reduce using rule 11 (statement -> selection_statement .)
    IF              reduce using rule 11 (statement -> selection_statement .)
    FOR             reduce using rule 11 (statement -> selection_statement .)
    WHILE           reduce using rule 11 (statement -> selection_statement .)
    DO              reduce using rule 11 (statement -> selection_statement .)
    RETURN          reduce using rule 11 (statement -> selection_statement .)
    CONTINUE        reduce using rule 11 (statement -> selection_statement .)
    BREAK           reduce using rule 11 (statement -> selection_statement .)
    IDENT           reduce using rule 11 (statement -> selection_statement .)
    NOT             reduce using rule 11 (statement -> selection_statement .)
    SUB             reduce using rule 11 (statement -> selection_statement .)
    ADD             reduce using rule 11 (statement -> selection_statement .)
    LPAREN          reduce using rule 11 (statement -> selection_statement .)
    NUMBER          reduce using rule 11 (statement -> selection_statement .)
    STRING          reduce using rule 11 (statement -> selection_statement .)
    TRUE            reduce using rule 11 (statement -> selection_statement .)
    FALSE           reduce using rule 11 (statement -> selection_statement .)
    ELSE            reduce using rule 11 (statement -> selection_statement .)


state 128

    (12) statement -> iteration_statement .

    RBRACE          reduce using rule 12 (statement -> iteration_statement .)
    LBRACE          reduce using rule 12 (statement -> iteration_statement .)
    SEMICOLON       reduce using rule 12 (statement -> iteration_statement .)
    IF              reduce using rule 12 (statement -> iteration_statement .)
    FOR             reduce using rule 12 (statement -> iteration_statement .)
    WHILE           reduce using rule 12 (statement -> iteration_statement .)
    DO              reduce using rule 12 (statement -> iteration_statement .)
    RETURN          reduce using rule 12 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 12 (statement -> iteration_statement .)
    BREAK           reduce using rule 12 (statement -> iteration_statement .)
    IDENT           reduce using rule 12 (statement -> iteration_statement .)
    NOT             reduce using rule 12 (statement -> iteration_statement .)
    SUB             reduce using rule 12 (statement -> iteration_statement .)
    ADD             reduce using rule 12 (statement -> iteration_statement .)
    LPAREN          reduce using rule 12 (statement -> iteration_statement .)
    NUMBER          reduce using rule 12 (statement -> iteration_statement .)
    STRING          reduce using rule 12 (statement -> iteration_statement .)
    TRUE            reduce using rule 12 (statement -> iteration_statement .)
    FALSE           reduce using rule 12 (statement -> iteration_statement .)
    ELSE            reduce using rule 12 (statement -> iteration_statement .)


state 129

    (13) statement -> jump_statement .

    RBRACE          reduce using rule 13 (statement -> jump_statement .)
    LBRACE          reduce using rule 13 (statement -> jump_statement .)
    SEMICOLON       reduce using rule 13 (statement -> jump_statement .)
    IF              reduce using rule 13 (statement -> jump_statement .)
    FOR             reduce using rule 13 (statement -> jump_statement .)
    WHILE           reduce using rule 13 (statement -> jump_statement .)
    DO              reduce using rule 13 (statement -> jump_statement .)
    RETURN          reduce using rule 13 (statement -> jump_statement .)
    CONTINUE        reduce using rule 13 (statement -> jump_statement .)
    BREAK           reduce using rule 13 (statement -> jump_statement .)
    IDENT           reduce using rule 13 (statement -> jump_statement .)
    NOT             reduce using rule 13 (statement -> jump_statement .)
    SUB             reduce using rule 13 (statement -> jump_statement .)
    ADD             reduce using rule 13 (statement -> jump_statement .)
    LPAREN          reduce using rule 13 (statement -> jump_statement .)
    NUMBER          reduce using rule 13 (statement -> jump_statement .)
    STRING          reduce using rule 13 (statement -> jump_statement .)
    TRUE            reduce using rule 13 (statement -> jump_statement .)
    FALSE           reduce using rule 13 (statement -> jump_statement .)
    ELSE            reduce using rule 13 (statement -> jump_statement .)


state 130

    (14) simple_statement -> semicolons .
    (122) semicolons -> semicolons . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    RBRACE          reduce using rule 14 (simple_statement -> semicolons .)
    LBRACE          reduce using rule 14 (simple_statement -> semicolons .)
    IF              reduce using rule 14 (simple_statement -> semicolons .)
    FOR             reduce using rule 14 (simple_statement -> semicolons .)
    WHILE           reduce using rule 14 (simple_statement -> semicolons .)
    DO              reduce using rule 14 (simple_statement -> semicolons .)
    RETURN          reduce using rule 14 (simple_statement -> semicolons .)
    CONTINUE        reduce using rule 14 (simple_statement -> semicolons .)
    BREAK           reduce using rule 14 (simple_statement -> semicolons .)
    IDENT           reduce using rule 14 (simple_statement -> semicolons .)
    NOT             reduce using rule 14 (simple_statement -> semicolons .)
    SUB             reduce using rule 14 (simple_statement -> semicolons .)
    ADD             reduce using rule 14 (simple_statement -> semicolons .)
    LPAREN          reduce using rule 14 (simple_statement -> semicolons .)
    NUMBER          reduce using rule 14 (simple_statement -> semicolons .)
    STRING          reduce using rule 14 (simple_statement -> semicolons .)
    TRUE            reduce using rule 14 (simple_statement -> semicolons .)
    FALSE           reduce using rule 14 (simple_statement -> semicolons .)
    ELSE            reduce using rule 14 (simple_statement -> semicolons .)
    SEMICOLON       shift and go to state 11

  ! SEMICOLON       [ reduce using rule 14 (simple_statement -> semicolons .) ]


state 131

    (15) simple_statement -> expression . semicolons
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON

    SEMICOLON       shift and go to state 6

    semicolons                     shift and go to state 155

state 132

    (17) selection_statement -> if .

    RBRACE          reduce using rule 17 (selection_statement -> if .)
    LBRACE          reduce using rule 17 (selection_statement -> if .)
    SEMICOLON       reduce using rule 17 (selection_statement -> if .)
    IF              reduce using rule 17 (selection_statement -> if .)
    FOR             reduce using rule 17 (selection_statement -> if .)
    WHILE           reduce using rule 17 (selection_statement -> if .)
    DO              reduce using rule 17 (selection_statement -> if .)
    RETURN          reduce using rule 17 (selection_statement -> if .)
    CONTINUE        reduce using rule 17 (selection_statement -> if .)
    BREAK           reduce using rule 17 (selection_statement -> if .)
    IDENT           reduce using rule 17 (selection_statement -> if .)
    NOT             reduce using rule 17 (selection_statement -> if .)
    SUB             reduce using rule 17 (selection_statement -> if .)
    ADD             reduce using rule 17 (selection_statement -> if .)
    LPAREN          reduce using rule 17 (selection_statement -> if .)
    NUMBER          reduce using rule 17 (selection_statement -> if .)
    STRING          reduce using rule 17 (selection_statement -> if .)
    TRUE            reduce using rule 17 (selection_statement -> if .)
    FALSE           reduce using rule 17 (selection_statement -> if .)
    ELSE            reduce using rule 17 (selection_statement -> if .)


state 133

    (25) iteration_statement -> for .

    RBRACE          reduce using rule 25 (iteration_statement -> for .)
    LBRACE          reduce using rule 25 (iteration_statement -> for .)
    SEMICOLON       reduce using rule 25 (iteration_statement -> for .)
    IF              reduce using rule 25 (iteration_statement -> for .)
    FOR             reduce using rule 25 (iteration_statement -> for .)
    WHILE           reduce using rule 25 (iteration_statement -> for .)
    DO              reduce using rule 25 (iteration_statement -> for .)
    RETURN          reduce using rule 25 (iteration_statement -> for .)
    CONTINUE        reduce using rule 25 (iteration_statement -> for .)
    BREAK           reduce using rule 25 (iteration_statement -> for .)
    IDENT           reduce using rule 25 (iteration_statement -> for .)
    NOT             reduce using rule 25 (iteration_statement -> for .)
    SUB             reduce using rule 25 (iteration_statement -> for .)
    ADD             reduce using rule 25 (iteration_statement -> for .)
    LPAREN          reduce using rule 25 (iteration_statement -> for .)
    NUMBER          reduce using rule 25 (iteration_statement -> for .)
    STRING          reduce using rule 25 (iteration_statement -> for .)
    TRUE            reduce using rule 25 (iteration_statement -> for .)
    FALSE           reduce using rule 25 (iteration_statement -> for .)
    ELSE            reduce using rule 25 (iteration_statement -> for .)


state 134

    (26) iteration_statement -> while .

    RBRACE          reduce using rule 26 (iteration_statement -> while .)
    LBRACE          reduce using rule 26 (iteration_statement -> while .)
    SEMICOLON       reduce using rule 26 (iteration_statement -> while .)
    IF              reduce using rule 26 (iteration_statement -> while .)
    FOR             reduce using rule 26 (iteration_statement -> while .)
    WHILE           reduce using rule 26 (iteration_statement -> while .)
    DO              reduce using rule 26 (iteration_statement -> while .)
    RETURN          reduce using rule 26 (iteration_statement -> while .)
    CONTINUE        reduce using rule 26 (iteration_statement -> while .)
    BREAK           reduce using rule 26 (iteration_statement -> while .)
    IDENT           reduce using rule 26 (iteration_statement -> while .)
    NOT             reduce using rule 26 (iteration_statement -> while .)
    SUB             reduce using rule 26 (iteration_statement -> while .)
    ADD             reduce using rule 26 (iteration_statement -> while .)
    LPAREN          reduce using rule 26 (iteration_statement -> while .)
    NUMBER          reduce using rule 26 (iteration_statement -> while .)
    STRING          reduce using rule 26 (iteration_statement -> while .)
    TRUE            reduce using rule 26 (iteration_statement -> while .)
    FALSE           reduce using rule 26 (iteration_statement -> while .)
    ELSE            reduce using rule 26 (iteration_statement -> while .)


state 135

    (27) iteration_statement -> dowhile .

    RBRACE          reduce using rule 27 (iteration_statement -> dowhile .)
    LBRACE          reduce using rule 27 (iteration_statement -> dowhile .)
    SEMICOLON       reduce using rule 27 (iteration_statement -> dowhile .)
    IF              reduce using rule 27 (iteration_statement -> dowhile .)
    FOR             reduce using rule 27 (iteration_statement -> dowhile .)
    WHILE           reduce using rule 27 (iteration_statement -> dowhile .)
    DO              reduce using rule 27 (iteration_statement -> dowhile .)
    RETURN          reduce using rule 27 (iteration_statement -> dowhile .)
    CONTINUE        reduce using rule 27 (iteration_statement -> dowhile .)
    BREAK           reduce using rule 27 (iteration_statement -> dowhile .)
    IDENT           reduce using rule 27 (iteration_statement -> dowhile .)
    NOT             reduce using rule 27 (iteration_statement -> dowhile .)
    SUB             reduce using rule 27 (iteration_statement -> dowhile .)
    ADD             reduce using rule 27 (iteration_statement -> dowhile .)
    LPAREN          reduce using rule 27 (iteration_statement -> dowhile .)
    NUMBER          reduce using rule 27 (iteration_statement -> dowhile .)
    STRING          reduce using rule 27 (iteration_statement -> dowhile .)
    TRUE            reduce using rule 27 (iteration_statement -> dowhile .)
    FALSE           reduce using rule 27 (iteration_statement -> dowhile .)
    ELSE            reduce using rule 27 (iteration_statement -> dowhile .)


state 136

    (18) jump_statement -> return .

    RBRACE          reduce using rule 18 (jump_statement -> return .)
    LBRACE          reduce using rule 18 (jump_statement -> return .)
    SEMICOLON       reduce using rule 18 (jump_statement -> return .)
    IF              reduce using rule 18 (jump_statement -> return .)
    FOR             reduce using rule 18 (jump_statement -> return .)
    WHILE           reduce using rule 18 (jump_statement -> return .)
    DO              reduce using rule 18 (jump_statement -> return .)
    RETURN          reduce using rule 18 (jump_statement -> return .)
    CONTINUE        reduce using rule 18 (jump_statement -> return .)
    BREAK           reduce using rule 18 (jump_statement -> return .)
    IDENT           reduce using rule 18 (jump_statement -> return .)
    NOT             reduce using rule 18 (jump_statement -> return .)
    SUB             reduce using rule 18 (jump_statement -> return .)
    ADD             reduce using rule 18 (jump_statement -> return .)
    LPAREN          reduce using rule 18 (jump_statement -> return .)
    NUMBER          reduce using rule 18 (jump_statement -> return .)
    STRING          reduce using rule 18 (jump_statement -> return .)
    TRUE            reduce using rule 18 (jump_statement -> return .)
    FALSE           reduce using rule 18 (jump_statement -> return .)
    ELSE            reduce using rule 18 (jump_statement -> return .)


state 137

    (19) jump_statement -> continue .

    RBRACE          reduce using rule 19 (jump_statement -> continue .)
    LBRACE          reduce using rule 19 (jump_statement -> continue .)
    SEMICOLON       reduce using rule 19 (jump_statement -> continue .)
    IF              reduce using rule 19 (jump_statement -> continue .)
    FOR             reduce using rule 19 (jump_statement -> continue .)
    WHILE           reduce using rule 19 (jump_statement -> continue .)
    DO              reduce using rule 19 (jump_statement -> continue .)
    RETURN          reduce using rule 19 (jump_statement -> continue .)
    CONTINUE        reduce using rule 19 (jump_statement -> continue .)
    BREAK           reduce using rule 19 (jump_statement -> continue .)
    IDENT           reduce using rule 19 (jump_statement -> continue .)
    NOT             reduce using rule 19 (jump_statement -> continue .)
    SUB             reduce using rule 19 (jump_statement -> continue .)
    ADD             reduce using rule 19 (jump_statement -> continue .)
    LPAREN          reduce using rule 19 (jump_statement -> continue .)
    NUMBER          reduce using rule 19 (jump_statement -> continue .)
    STRING          reduce using rule 19 (jump_statement -> continue .)
    TRUE            reduce using rule 19 (jump_statement -> continue .)
    FALSE           reduce using rule 19 (jump_statement -> continue .)
    ELSE            reduce using rule 19 (jump_statement -> continue .)


state 138

    (20) jump_statement -> break .

    RBRACE          reduce using rule 20 (jump_statement -> break .)
    LBRACE          reduce using rule 20 (jump_statement -> break .)
    SEMICOLON       reduce using rule 20 (jump_statement -> break .)
    IF              reduce using rule 20 (jump_statement -> break .)
    FOR             reduce using rule 20 (jump_statement -> break .)
    WHILE           reduce using rule 20 (jump_statement -> break .)
    DO              reduce using rule 20 (jump_statement -> break .)
    RETURN          reduce using rule 20 (jump_statement -> break .)
    CONTINUE        reduce using rule 20 (jump_statement -> break .)
    BREAK           reduce using rule 20 (jump_statement -> break .)
    IDENT           reduce using rule 20 (jump_statement -> break .)
    NOT             reduce using rule 20 (jump_statement -> break .)
    SUB             reduce using rule 20 (jump_statement -> break .)
    ADD             reduce using rule 20 (jump_statement -> break .)
    LPAREN          reduce using rule 20 (jump_statement -> break .)
    NUMBER          reduce using rule 20 (jump_statement -> break .)
    STRING          reduce using rule 20 (jump_statement -> break .)
    TRUE            reduce using rule 20 (jump_statement -> break .)
    FALSE           reduce using rule 20 (jump_statement -> break .)
    ELSE            reduce using rule 20 (jump_statement -> break .)


state 139

    (28) expression -> logical_expression .

    SEMICOLON       reduce using rule 28 (expression -> logical_expression .)
    COMMA           reduce using rule 28 (expression -> logical_expression .)
    RPAREN          reduce using rule 28 (expression -> logical_expression .)


state 140

    (29) expression -> assignment .

    SEMICOLON       reduce using rule 29 (expression -> assignment .)
    COMMA           reduce using rule 29 (expression -> assignment .)
    RPAREN          reduce using rule 29 (expression -> assignment .)


state 141

    (30) expression -> vars_declaration .

    SEMICOLON       reduce using rule 30 (expression -> vars_declaration .)
    COMMA           reduce using rule 30 (expression -> vars_declaration .)
    RPAREN          reduce using rule 30 (expression -> vars_declaration .)


state 142

    (67) if -> IF . LPAREN logical_expression RPAREN statement
    (68) if -> IF . LPAREN logical_expression RPAREN statement ELSE statement

    LPAREN          shift and go to state 156


state 143

    (113) for -> FOR . LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement

    LPAREN          shift and go to state 157


state 144

    (117) while -> WHILE . LPAREN logical_expression RPAREN statement

    LPAREN          shift and go to state 158


state 145

    (116) dowhile -> DO . statement WHILE LPAREN logical_expression RPAREN semicolons
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    statement                      shift and go to state 159
    logical_expression             shift and go to state 139
    semicolons                     shift and go to state 130
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 146

    (21) return -> RETURN .
    (22) return -> RETURN . logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
    RBRACE          reduce using rule 21 (return -> RETURN .)
    LBRACE          reduce using rule 21 (return -> RETURN .)
    SEMICOLON       reduce using rule 21 (return -> RETURN .)
    IF              reduce using rule 21 (return -> RETURN .)
    FOR             reduce using rule 21 (return -> RETURN .)
    WHILE           reduce using rule 21 (return -> RETURN .)
    DO              reduce using rule 21 (return -> RETURN .)
    RETURN          reduce using rule 21 (return -> RETURN .)
    CONTINUE        reduce using rule 21 (return -> RETURN .)
    BREAK           reduce using rule 21 (return -> RETURN .)
    ELSE            reduce using rule 21 (return -> RETURN .)
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

  ! IDENT           [ reduce using rule 21 (return -> RETURN .) ]
  ! NOT             [ reduce using rule 21 (return -> RETURN .) ]
  ! SUB             [ reduce using rule 21 (return -> RETURN .) ]
  ! ADD             [ reduce using rule 21 (return -> RETURN .) ]
  ! LPAREN          [ reduce using rule 21 (return -> RETURN .) ]
  ! NUMBER          [ reduce using rule 21 (return -> RETURN .) ]
  ! STRING          [ reduce using rule 21 (return -> RETURN .) ]
  ! TRUE            [ reduce using rule 21 (return -> RETURN .) ]
  ! FALSE           [ reduce using rule 21 (return -> RETURN .) ]

    logical_expression             shift and go to state 160
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 147

    (23) continue -> CONTINUE .

    RBRACE          reduce using rule 23 (continue -> CONTINUE .)
    LBRACE          reduce using rule 23 (continue -> CONTINUE .)
    SEMICOLON       reduce using rule 23 (continue -> CONTINUE .)
    IF              reduce using rule 23 (continue -> CONTINUE .)
    FOR             reduce using rule 23 (continue -> CONTINUE .)
    WHILE           reduce using rule 23 (continue -> CONTINUE .)
    DO              reduce using rule 23 (continue -> CONTINUE .)
    RETURN          reduce using rule 23 (continue -> CONTINUE .)
    CONTINUE        reduce using rule 23 (continue -> CONTINUE .)
    BREAK           reduce using rule 23 (continue -> CONTINUE .)
    IDENT           reduce using rule 23 (continue -> CONTINUE .)
    NOT             reduce using rule 23 (continue -> CONTINUE .)
    SUB             reduce using rule 23 (continue -> CONTINUE .)
    ADD             reduce using rule 23 (continue -> CONTINUE .)
    LPAREN          reduce using rule 23 (continue -> CONTINUE .)
    NUMBER          reduce using rule 23 (continue -> CONTINUE .)
    STRING          reduce using rule 23 (continue -> CONTINUE .)
    TRUE            reduce using rule 23 (continue -> CONTINUE .)
    FALSE           reduce using rule 23 (continue -> CONTINUE .)
    ELSE            reduce using rule 23 (continue -> CONTINUE .)


state 148

    (24) break -> BREAK .

    RBRACE          reduce using rule 24 (break -> BREAK .)
    LBRACE          reduce using rule 24 (break -> BREAK .)
    SEMICOLON       reduce using rule 24 (break -> BREAK .)
    IF              reduce using rule 24 (break -> BREAK .)
    FOR             reduce using rule 24 (break -> BREAK .)
    WHILE           reduce using rule 24 (break -> BREAK .)
    DO              reduce using rule 24 (break -> BREAK .)
    RETURN          reduce using rule 24 (break -> BREAK .)
    CONTINUE        reduce using rule 24 (break -> BREAK .)
    BREAK           reduce using rule 24 (break -> BREAK .)
    IDENT           reduce using rule 24 (break -> BREAK .)
    NOT             reduce using rule 24 (break -> BREAK .)
    SUB             reduce using rule 24 (break -> BREAK .)
    ADD             reduce using rule 24 (break -> BREAK .)
    LPAREN          reduce using rule 24 (break -> BREAK .)
    NUMBER          reduce using rule 24 (break -> BREAK .)
    STRING          reduce using rule 24 (break -> BREAK .)
    TRUE            reduce using rule 24 (break -> BREAK .)
    FALSE           reduce using rule 24 (break -> BREAK .)
    ELSE            reduce using rule 24 (break -> BREAK .)


state 149

    (69) assignment -> lvalue . assignment_operation rvalue
    (59) postfix_expression -> lvalue . INC_OP
    (60) postfix_expression -> lvalue . DEC_OP
    (62) group -> lvalue .
    (73) assignment_operation -> . ASSIGN
    (74) assignment_operation -> . ADD_ASSIGN
    (75) assignment_operation -> . SUB_ASSIGN
    (76) assignment_operation -> . MUL_ASSIGN
    (77) assignment_operation -> . DIV_ASSIGN
    (78) assignment_operation -> . MOD_ASSIGN

    INC_OP          shift and go to state 70
    DEC_OP          shift and go to state 71
    MUL             reduce using rule 62 (group -> lvalue .)
    DIV             reduce using rule 62 (group -> lvalue .)
    MOD             reduce using rule 62 (group -> lvalue .)
    ADD             reduce using rule 62 (group -> lvalue .)
    SUB             reduce using rule 62 (group -> lvalue .)
    GT              reduce using rule 62 (group -> lvalue .)
    LT              reduce using rule 62 (group -> lvalue .)
    GE              reduce using rule 62 (group -> lvalue .)
    LE              reduce using rule 62 (group -> lvalue .)
    EQUALS          reduce using rule 62 (group -> lvalue .)
    NOTEQUALS       reduce using rule 62 (group -> lvalue .)
    AND             reduce using rule 62 (group -> lvalue .)
    OR              reduce using rule 62 (group -> lvalue .)
    SEMICOLON       reduce using rule 62 (group -> lvalue .)
    COMMA           reduce using rule 62 (group -> lvalue .)
    RPAREN          reduce using rule 62 (group -> lvalue .)
    ASSIGN          shift and go to state 162
    ADD_ASSIGN      shift and go to state 163
    SUB_ASSIGN      shift and go to state 164
    MUL_ASSIGN      shift and go to state 165
    DIV_ASSIGN      shift and go to state 166
    MOD_ASSIGN      shift and go to state 167

    assignment_operation           shift and go to state 161

state 150

    (91) vars_declaration -> type . init_declarator_list
    (96) init_declarator_list -> . init_declarator
    (97) init_declarator_list -> . init_declarator_list COMMA init_declarator
    (100) init_declarator -> . ident
    (101) init_declarator -> . ident_initializer
    (93) ident -> . IDENT
    (104) ident_initializer -> . ident ASSIGN simple_rvalue

    IDENT           shift and go to state 16

    init_declarator_list           shift and go to state 13
    init_declarator                shift and go to state 15
    ident                          shift and go to state 30
    ident_initializer              shift and go to state 17

state 151

    (95) type -> IDENT .
    (94) type_array -> IDENT . BRACKETS
    (93) ident -> IDENT .

    IDENT           reduce using rule 95 (type -> IDENT .)
    BRACKETS        shift and go to state 23
    LBRACKET        reduce using rule 93 (ident -> IDENT .)
    LPAREN          reduce using rule 93 (ident -> IDENT .)
    INC_OP          reduce using rule 93 (ident -> IDENT .)
    DEC_OP          reduce using rule 93 (ident -> IDENT .)
    ASSIGN          reduce using rule 93 (ident -> IDENT .)
    ADD_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    SUB_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    MUL_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    DIV_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    MOD_ASSIGN      reduce using rule 93 (ident -> IDENT .)
    MUL             reduce using rule 93 (ident -> IDENT .)
    DIV             reduce using rule 93 (ident -> IDENT .)
    MOD             reduce using rule 93 (ident -> IDENT .)
    ADD             reduce using rule 93 (ident -> IDENT .)
    SUB             reduce using rule 93 (ident -> IDENT .)
    GT              reduce using rule 93 (ident -> IDENT .)
    LT              reduce using rule 93 (ident -> IDENT .)
    GE              reduce using rule 93 (ident -> IDENT .)
    LE              reduce using rule 93 (ident -> IDENT .)
    EQUALS          reduce using rule 93 (ident -> IDENT .)
    NOTEQUALS       reduce using rule 93 (ident -> IDENT .)
    AND             reduce using rule 93 (ident -> IDENT .)
    OR              reduce using rule 93 (ident -> IDENT .)
    SEMICOLON       reduce using rule 93 (ident -> IDENT .)
    COMMA           reduce using rule 93 (ident -> IDENT .)
    RPAREN          reduce using rule 93 (ident -> IDENT .)


state 152

    (90) args_list -> args_list COMMA logical_expression .

    RPAREN          reduce using rule 90 (args_list -> args_list COMMA logical_expression .)
    COMMA           reduce using rule 90 (args_list -> args_list COMMA logical_expression .)
    RBRACE          reduce using rule 90 (args_list -> args_list COMMA logical_expression .)


state 153

    (106) array_value -> NEW type LBRACKET logical_expression RBRACKET .
    (108) array_value -> NEW type LBRACKET logical_expression RBRACKET . LBRACE args_list RBRACE

    COMMA           reduce using rule 106 (array_value -> NEW type LBRACKET logical_expression RBRACKET .)
    SEMICOLON       reduce using rule 106 (array_value -> NEW type LBRACKET logical_expression RBRACKET .)
    RPAREN          reduce using rule 106 (array_value -> NEW type LBRACKET logical_expression RBRACKET .)
    LBRACE          shift and go to state 168


state 154

    (107) array_value -> NEW type BRACKETS LBRACE args_list . RBRACE
    (90) args_list -> args_list . COMMA logical_expression

    RBRACE          shift and go to state 169
    COMMA           shift and go to state 120


state 155

    (15) simple_statement -> expression semicolons .
    (122) semicolons -> semicolons . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    RBRACE          reduce using rule 15 (simple_statement -> expression semicolons .)
    LBRACE          reduce using rule 15 (simple_statement -> expression semicolons .)
    IF              reduce using rule 15 (simple_statement -> expression semicolons .)
    FOR             reduce using rule 15 (simple_statement -> expression semicolons .)
    WHILE           reduce using rule 15 (simple_statement -> expression semicolons .)
    DO              reduce using rule 15 (simple_statement -> expression semicolons .)
    RETURN          reduce using rule 15 (simple_statement -> expression semicolons .)
    CONTINUE        reduce using rule 15 (simple_statement -> expression semicolons .)
    BREAK           reduce using rule 15 (simple_statement -> expression semicolons .)
    IDENT           reduce using rule 15 (simple_statement -> expression semicolons .)
    NOT             reduce using rule 15 (simple_statement -> expression semicolons .)
    SUB             reduce using rule 15 (simple_statement -> expression semicolons .)
    ADD             reduce using rule 15 (simple_statement -> expression semicolons .)
    LPAREN          reduce using rule 15 (simple_statement -> expression semicolons .)
    NUMBER          reduce using rule 15 (simple_statement -> expression semicolons .)
    STRING          reduce using rule 15 (simple_statement -> expression semicolons .)
    TRUE            reduce using rule 15 (simple_statement -> expression semicolons .)
    FALSE           reduce using rule 15 (simple_statement -> expression semicolons .)
    ELSE            reduce using rule 15 (simple_statement -> expression semicolons .)
    SEMICOLON       shift and go to state 11

  ! SEMICOLON       [ reduce using rule 15 (simple_statement -> expression semicolons .) ]


state 156

    (67) if -> IF LPAREN . logical_expression RPAREN statement
    (68) if -> IF LPAREN . logical_expression RPAREN statement ELSE statement
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 170
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 157

    (113) for -> FOR LPAREN . expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (31) expression_list -> .
    (32) expression_list -> . expression
    (33) expression_list -> . expression_list COMMA expression
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    SEMICOLON       reduce using rule 31 (expression_list -> .)
    COMMA           reduce using rule 31 (expression_list -> .)
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    expression_list                shift and go to state 171
    expression                     shift and go to state 172
    logical_expression             shift and go to state 139
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 158

    (117) while -> WHILE LPAREN . logical_expression RPAREN statement
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 173
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 159

    (116) dowhile -> DO statement . WHILE LPAREN logical_expression RPAREN semicolons

    WHILE           shift and go to state 174


state 160

    (22) return -> RETURN logical_expression .

    RBRACE          reduce using rule 22 (return -> RETURN logical_expression .)
    LBRACE          reduce using rule 22 (return -> RETURN logical_expression .)
    SEMICOLON       reduce using rule 22 (return -> RETURN logical_expression .)
    IF              reduce using rule 22 (return -> RETURN logical_expression .)
    FOR             reduce using rule 22 (return -> RETURN logical_expression .)
    WHILE           reduce using rule 22 (return -> RETURN logical_expression .)
    DO              reduce using rule 22 (return -> RETURN logical_expression .)
    RETURN          reduce using rule 22 (return -> RETURN logical_expression .)
    CONTINUE        reduce using rule 22 (return -> RETURN logical_expression .)
    BREAK           reduce using rule 22 (return -> RETURN logical_expression .)
    IDENT           reduce using rule 22 (return -> RETURN logical_expression .)
    NOT             reduce using rule 22 (return -> RETURN logical_expression .)
    SUB             reduce using rule 22 (return -> RETURN logical_expression .)
    ADD             reduce using rule 22 (return -> RETURN logical_expression .)
    LPAREN          reduce using rule 22 (return -> RETURN logical_expression .)
    NUMBER          reduce using rule 22 (return -> RETURN logical_expression .)
    STRING          reduce using rule 22 (return -> RETURN logical_expression .)
    TRUE            reduce using rule 22 (return -> RETURN logical_expression .)
    FALSE           reduce using rule 22 (return -> RETURN logical_expression .)
    ELSE            reduce using rule 22 (return -> RETURN logical_expression .)


state 161

    (69) assignment -> lvalue assignment_operation . rvalue
    (70) rvalue -> . logical_expression
    (71) rvalue -> . array_value
    (72) rvalue -> . lvalue assignment_operation rvalue
    (34) logical_expression -> . logical_or_expression
    (106) array_value -> . NEW type LBRACKET logical_expression RBRACKET
    (107) array_value -> . NEW type BRACKETS LBRACE args_list RBRACE
    (108) array_value -> . NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    NEW             shift and go to state 63
    IDENT           shift and go to state 16
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    lvalue                         shift and go to state 175
    rvalue                         shift and go to state 176
    logical_expression             shift and go to state 177
    array_value                    shift and go to state 178
    logical_or_expression          shift and go to state 39
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 162

    (73) assignment_operation -> ASSIGN .

    NEW             reduce using rule 73 (assignment_operation -> ASSIGN .)
    IDENT           reduce using rule 73 (assignment_operation -> ASSIGN .)
    NOT             reduce using rule 73 (assignment_operation -> ASSIGN .)
    SUB             reduce using rule 73 (assignment_operation -> ASSIGN .)
    ADD             reduce using rule 73 (assignment_operation -> ASSIGN .)
    LPAREN          reduce using rule 73 (assignment_operation -> ASSIGN .)
    NUMBER          reduce using rule 73 (assignment_operation -> ASSIGN .)
    STRING          reduce using rule 73 (assignment_operation -> ASSIGN .)
    TRUE            reduce using rule 73 (assignment_operation -> ASSIGN .)
    FALSE           reduce using rule 73 (assignment_operation -> ASSIGN .)


state 163

    (74) assignment_operation -> ADD_ASSIGN .

    NEW             reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    IDENT           reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    NOT             reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    SUB             reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    ADD             reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    LPAREN          reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    NUMBER          reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    STRING          reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    TRUE            reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)
    FALSE           reduce using rule 74 (assignment_operation -> ADD_ASSIGN .)


state 164

    (75) assignment_operation -> SUB_ASSIGN .

    NEW             reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    IDENT           reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    NOT             reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    SUB             reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    ADD             reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    LPAREN          reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    NUMBER          reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    STRING          reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    TRUE            reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)
    FALSE           reduce using rule 75 (assignment_operation -> SUB_ASSIGN .)


state 165

    (76) assignment_operation -> MUL_ASSIGN .

    NEW             reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    IDENT           reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    NOT             reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    SUB             reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    ADD             reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    LPAREN          reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    NUMBER          reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    STRING          reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    TRUE            reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)
    FALSE           reduce using rule 76 (assignment_operation -> MUL_ASSIGN .)


state 166

    (77) assignment_operation -> DIV_ASSIGN .

    NEW             reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    IDENT           reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    NOT             reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    SUB             reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    ADD             reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    LPAREN          reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    NUMBER          reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    STRING          reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    TRUE            reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)
    FALSE           reduce using rule 77 (assignment_operation -> DIV_ASSIGN .)


state 167

    (78) assignment_operation -> MOD_ASSIGN .

    NEW             reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    IDENT           reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    NOT             reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    SUB             reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    ADD             reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    LPAREN          reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    NUMBER          reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    STRING          reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    TRUE            reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)
    FALSE           reduce using rule 78 (assignment_operation -> MOD_ASSIGN .)


state 168

    (108) array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE . args_list RBRACE
    (88) args_list -> .
    (89) args_list -> . logical_expression
    (90) args_list -> . args_list COMMA logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    RBRACE          reduce using rule 88 (args_list -> .)
    COMMA           reduce using rule 88 (args_list -> .)
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 99
    args_list                      shift and go to state 179
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 169

    (107) array_value -> NEW type BRACKETS LBRACE args_list RBRACE .

    COMMA           reduce using rule 107 (array_value -> NEW type BRACKETS LBRACE args_list RBRACE .)
    SEMICOLON       reduce using rule 107 (array_value -> NEW type BRACKETS LBRACE args_list RBRACE .)
    RPAREN          reduce using rule 107 (array_value -> NEW type BRACKETS LBRACE args_list RBRACE .)


state 170

    (67) if -> IF LPAREN logical_expression . RPAREN statement
    (68) if -> IF LPAREN logical_expression . RPAREN statement ELSE statement

    RPAREN          shift and go to state 180


state 171

    (113) for -> FOR LPAREN expression_list . SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (33) expression_list -> expression_list . COMMA expression

    SEMICOLON       shift and go to state 181
    COMMA           shift and go to state 182


state 172

    (32) expression_list -> expression .

    SEMICOLON       reduce using rule 32 (expression_list -> expression .)
    COMMA           reduce using rule 32 (expression_list -> expression .)
    RPAREN          reduce using rule 32 (expression_list -> expression .)


state 173

    (117) while -> WHILE LPAREN logical_expression . RPAREN statement

    RPAREN          shift and go to state 183


state 174

    (116) dowhile -> DO statement WHILE . LPAREN logical_expression RPAREN semicolons

    LPAREN          shift and go to state 184


state 175

    (72) rvalue -> lvalue . assignment_operation rvalue
    (59) postfix_expression -> lvalue . INC_OP
    (60) postfix_expression -> lvalue . DEC_OP
    (62) group -> lvalue .
    (73) assignment_operation -> . ASSIGN
    (74) assignment_operation -> . ADD_ASSIGN
    (75) assignment_operation -> . SUB_ASSIGN
    (76) assignment_operation -> . MUL_ASSIGN
    (77) assignment_operation -> . DIV_ASSIGN
    (78) assignment_operation -> . MOD_ASSIGN

    INC_OP          shift and go to state 70
    DEC_OP          shift and go to state 71
    MUL             reduce using rule 62 (group -> lvalue .)
    DIV             reduce using rule 62 (group -> lvalue .)
    MOD             reduce using rule 62 (group -> lvalue .)
    ADD             reduce using rule 62 (group -> lvalue .)
    SUB             reduce using rule 62 (group -> lvalue .)
    GT              reduce using rule 62 (group -> lvalue .)
    LT              reduce using rule 62 (group -> lvalue .)
    GE              reduce using rule 62 (group -> lvalue .)
    LE              reduce using rule 62 (group -> lvalue .)
    EQUALS          reduce using rule 62 (group -> lvalue .)
    NOTEQUALS       reduce using rule 62 (group -> lvalue .)
    AND             reduce using rule 62 (group -> lvalue .)
    OR              reduce using rule 62 (group -> lvalue .)
    SEMICOLON       reduce using rule 62 (group -> lvalue .)
    COMMA           reduce using rule 62 (group -> lvalue .)
    RPAREN          reduce using rule 62 (group -> lvalue .)
    ASSIGN          shift and go to state 162
    ADD_ASSIGN      shift and go to state 163
    SUB_ASSIGN      shift and go to state 164
    MUL_ASSIGN      shift and go to state 165
    DIV_ASSIGN      shift and go to state 166
    MOD_ASSIGN      shift and go to state 167

    assignment_operation           shift and go to state 185

state 176

    (69) assignment -> lvalue assignment_operation rvalue .

    SEMICOLON       reduce using rule 69 (assignment -> lvalue assignment_operation rvalue .)
    COMMA           reduce using rule 69 (assignment -> lvalue assignment_operation rvalue .)
    RPAREN          reduce using rule 69 (assignment -> lvalue assignment_operation rvalue .)


state 177

    (70) rvalue -> logical_expression .

    SEMICOLON       reduce using rule 70 (rvalue -> logical_expression .)
    COMMA           reduce using rule 70 (rvalue -> logical_expression .)
    RPAREN          reduce using rule 70 (rvalue -> logical_expression .)


state 178

    (71) rvalue -> array_value .

    SEMICOLON       reduce using rule 71 (rvalue -> array_value .)
    COMMA           reduce using rule 71 (rvalue -> array_value .)
    RPAREN          reduce using rule 71 (rvalue -> array_value .)


state 179

    (108) array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list . RBRACE
    (90) args_list -> args_list . COMMA logical_expression

    RBRACE          shift and go to state 186
    COMMA           shift and go to state 120


state 180

    (67) if -> IF LPAREN logical_expression RPAREN . statement
    (68) if -> IF LPAREN logical_expression RPAREN . statement ELSE statement
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    logical_expression             shift and go to state 139
    statement                      shift and go to state 187
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    semicolons                     shift and go to state 130
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 181

    (113) for -> FOR LPAREN expression_list SEMICOLON . for_condition SEMICOLON expression_list RPAREN statement
    (114) for_condition -> .
    (115) for_condition -> . logical_expression
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    SEMICOLON       reduce using rule 114 (for_condition -> .)
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    for_condition                  shift and go to state 188
    logical_expression             shift and go to state 189
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 182

    (33) expression_list -> expression_list COMMA . expression
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    expression                     shift and go to state 190
    logical_expression             shift and go to state 139
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 183

    (117) while -> WHILE LPAREN logical_expression RPAREN . statement
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    logical_expression             shift and go to state 139
    statement                      shift and go to state 191
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    semicolons                     shift and go to state 130
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 184

    (116) dowhile -> DO statement WHILE LPAREN . logical_expression RPAREN semicolons
    (34) logical_expression -> . logical_or_expression
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET

    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    IDENT           shift and go to state 16

    logical_expression             shift and go to state 192
    logical_or_expression          shift and go to state 39
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    lvalue                         shift and go to state 91
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56
    ident                          shift and go to state 92
    get_element                    shift and go to state 40

state 185

    (72) rvalue -> lvalue assignment_operation . rvalue
    (70) rvalue -> . logical_expression
    (71) rvalue -> . array_value
    (72) rvalue -> . lvalue assignment_operation rvalue
    (34) logical_expression -> . logical_or_expression
    (106) array_value -> . NEW type LBRACKET logical_expression RBRACKET
    (107) array_value -> . NEW type BRACKETS LBRACE args_list RBRACE
    (108) array_value -> . NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    NEW             shift and go to state 63
    IDENT           shift and go to state 16
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    lvalue                         shift and go to state 175
    rvalue                         shift and go to state 193
    logical_expression             shift and go to state 177
    array_value                    shift and go to state 178
    logical_or_expression          shift and go to state 39
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    logical_and_expression         shift and go to state 41
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 186

    (108) array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE .

    COMMA           reduce using rule 108 (array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE .)
    SEMICOLON       reduce using rule 108 (array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE .)
    RPAREN          reduce using rule 108 (array_value -> NEW type LBRACKET logical_expression RBRACKET LBRACE args_list RBRACE .)


state 187

    (67) if -> IF LPAREN logical_expression RPAREN statement .
    (68) if -> IF LPAREN logical_expression RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    LBRACE          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    SEMICOLON       reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    IF              reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    FOR             reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    WHILE           reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    DO              reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    RETURN          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    CONTINUE        reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    BREAK           reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    IDENT           reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    NOT             reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    SUB             reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    ADD             reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    LPAREN          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    NUMBER          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    STRING          reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    TRUE            reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    FALSE           reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .)
    ELSE            shift and go to state 194

  ! ELSE            [ reduce using rule 67 (if -> IF LPAREN logical_expression RPAREN statement .) ]


state 188

    (113) for -> FOR LPAREN expression_list SEMICOLON for_condition . SEMICOLON expression_list RPAREN statement

    SEMICOLON       shift and go to state 195


state 189

    (115) for_condition -> logical_expression .

    SEMICOLON       reduce using rule 115 (for_condition -> logical_expression .)


state 190

    (33) expression_list -> expression_list COMMA expression .

    SEMICOLON       reduce using rule 33 (expression_list -> expression_list COMMA expression .)
    COMMA           reduce using rule 33 (expression_list -> expression_list COMMA expression .)
    RPAREN          reduce using rule 33 (expression_list -> expression_list COMMA expression .)


state 191

    (117) while -> WHILE LPAREN logical_expression RPAREN statement .

    RBRACE          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    LBRACE          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    SEMICOLON       reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    IF              reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    FOR             reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    WHILE           reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    DO              reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    RETURN          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    CONTINUE        reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    BREAK           reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    IDENT           reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    NOT             reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    SUB             reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    ADD             reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    LPAREN          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    NUMBER          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    STRING          reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    TRUE            reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    FALSE           reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)
    ELSE            reduce using rule 117 (while -> WHILE LPAREN logical_expression RPAREN statement .)


state 192

    (116) dowhile -> DO statement WHILE LPAREN logical_expression . RPAREN semicolons

    RPAREN          shift and go to state 196


state 193

    (72) rvalue -> lvalue assignment_operation rvalue .

    SEMICOLON       reduce using rule 72 (rvalue -> lvalue assignment_operation rvalue .)
    COMMA           reduce using rule 72 (rvalue -> lvalue assignment_operation rvalue .)
    RPAREN          reduce using rule 72 (rvalue -> lvalue assignment_operation rvalue .)


state 194

    (68) if -> IF LPAREN logical_expression RPAREN statement ELSE . statement
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    logical_expression             shift and go to state 139
    statement                      shift and go to state 197
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    semicolons                     shift and go to state 130
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 195

    (113) for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON . expression_list RPAREN statement
    (31) expression_list -> .
    (32) expression_list -> . expression
    (33) expression_list -> . expression_list COMMA expression
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    RPAREN          reduce using rule 31 (expression_list -> .)
    COMMA           reduce using rule 31 (expression_list -> .)
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    expression_list                shift and go to state 198
    expression                     shift and go to state 172
    logical_expression             shift and go to state 139
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 196

    (116) dowhile -> DO statement WHILE LPAREN logical_expression RPAREN . semicolons
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON

    SEMICOLON       shift and go to state 6

    semicolons                     shift and go to state 199

state 197

    (68) if -> IF LPAREN logical_expression RPAREN statement ELSE statement .

    RBRACE          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    SEMICOLON       reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    IF              reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    DO              reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    RETURN          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    CONTINUE        reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    BREAK           reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    IDENT           reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    SUB             reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    ADD             reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    NUMBER          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    STRING          reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    TRUE            reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    FALSE           reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 68 (if -> IF LPAREN logical_expression RPAREN statement ELSE statement .)


state 198

    (113) for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list . RPAREN statement
    (33) expression_list -> expression_list . COMMA expression

    RPAREN          shift and go to state 200
    COMMA           shift and go to state 182


state 199

    (116) dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .
    (122) semicolons -> semicolons . SEMICOLON

  ! shift/reduce conflict for SEMICOLON resolved as shift
    RBRACE          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    LBRACE          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    IF              reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    FOR             reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    WHILE           reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    DO              reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    RETURN          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    CONTINUE        reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    BREAK           reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    IDENT           reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    NOT             reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    SUB             reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    ADD             reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    LPAREN          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    NUMBER          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    STRING          reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    TRUE            reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    FALSE           reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    ELSE            reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .)
    SEMICOLON       shift and go to state 11

  ! SEMICOLON       [ reduce using rule 116 (dowhile -> DO statement WHILE LPAREN logical_expression RPAREN semicolons .) ]


state 200

    (113) for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN . statement
    (9) statement -> . simple_statement
    (10) statement -> . block
    (11) statement -> . selection_statement
    (12) statement -> . iteration_statement
    (13) statement -> . jump_statement
    (14) simple_statement -> . semicolons
    (15) simple_statement -> . expression semicolons
    (16) block -> . LBRACE statement_list RBRACE
    (17) selection_statement -> . if
    (25) iteration_statement -> . for
    (26) iteration_statement -> . while
    (27) iteration_statement -> . dowhile
    (18) jump_statement -> . return
    (19) jump_statement -> . continue
    (20) jump_statement -> . break
    (121) semicolons -> . SEMICOLON
    (122) semicolons -> . semicolons SEMICOLON
    (28) expression -> . logical_expression
    (29) expression -> . assignment
    (30) expression -> . vars_declaration
    (67) if -> . IF LPAREN logical_expression RPAREN statement
    (68) if -> . IF LPAREN logical_expression RPAREN statement ELSE statement
    (113) for -> . FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement
    (117) while -> . WHILE LPAREN logical_expression RPAREN statement
    (116) dowhile -> . DO statement WHILE LPAREN logical_expression RPAREN semicolons
    (21) return -> . RETURN
    (22) return -> . RETURN logical_expression
    (23) continue -> . CONTINUE
    (24) break -> . BREAK
    (34) logical_expression -> . logical_or_expression
    (69) assignment -> . lvalue assignment_operation rvalue
    (91) vars_declaration -> . type init_declarator_list
    (92) vars_declaration -> . type_array init_array_declarator_list
    (35) logical_or_expression -> . logical_and_expression
    (36) logical_or_expression -> . logical_or_expression OR logical_and_expression
    (110) lvalue -> . ident
    (111) lvalue -> . get_element
    (95) type -> . IDENT
    (94) type_array -> . IDENT BRACKETS
    (37) logical_and_expression -> . equality_expression
    (38) logical_and_expression -> . logical_and_expression AND equality_expression
    (93) ident -> . IDENT
    (112) get_element -> . ident LBRACKET logical_expression RBRACKET
    (39) equality_expression -> . relational_expression
    (40) equality_expression -> . equality_expression EQUALS relational_expression
    (41) equality_expression -> . equality_expression NOTEQUALS relational_expression
    (42) relational_expression -> . additive_expression
    (43) relational_expression -> . relational_expression GT additive_expression
    (44) relational_expression -> . relational_expression LT additive_expression
    (45) relational_expression -> . relational_expression GE additive_expression
    (46) relational_expression -> . relational_expression LE additive_expression
    (47) additive_expression -> . multiplicative_expression
    (48) additive_expression -> . additive_expression ADD multiplicative_expression
    (49) additive_expression -> . additive_expression SUB multiplicative_expression
    (50) multiplicative_expression -> . unary_expression
    (51) multiplicative_expression -> . multiplicative_expression MUL unary_expression
    (52) multiplicative_expression -> . multiplicative_expression DIV unary_expression
    (53) multiplicative_expression -> . multiplicative_expression MOD unary_expression
    (54) unary_expression -> . postfix_expression
    (55) unary_expression -> . NOT group
    (56) unary_expression -> . SUB group
    (57) unary_expression -> . ADD group
    (58) postfix_expression -> . group
    (59) postfix_expression -> . lvalue INC_OP
    (60) postfix_expression -> . lvalue DEC_OP
    (61) group -> . call
    (62) group -> . lvalue
    (63) group -> . LPAREN logical_expression RPAREN
    (64) group -> . number
    (65) group -> . string
    (66) group -> . bool_value
    (82) call -> . ident LPAREN args_list RPAREN
    (120) number -> . NUMBER
    (81) string -> . STRING
    (118) bool_value -> . TRUE
    (119) bool_value -> . FALSE

    LBRACE          shift and go to state 95
    SEMICOLON       shift and go to state 6
    IF              shift and go to state 142
    FOR             shift and go to state 143
    WHILE           shift and go to state 144
    DO              shift and go to state 145
    RETURN          shift and go to state 146
    CONTINUE        shift and go to state 147
    BREAK           shift and go to state 148
    IDENT           shift and go to state 151
    NOT             shift and go to state 50
    SUB             shift and go to state 47
    ADD             shift and go to state 46
    LPAREN          shift and go to state 53
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    TRUE            shift and go to state 59
    FALSE           shift and go to state 60

    statement                      shift and go to state 201
    simple_statement               shift and go to state 125
    block                          shift and go to state 126
    selection_statement            shift and go to state 127
    iteration_statement            shift and go to state 128
    jump_statement                 shift and go to state 129
    semicolons                     shift and go to state 130
    expression                     shift and go to state 131
    if                             shift and go to state 132
    for                            shift and go to state 133
    while                          shift and go to state 134
    dowhile                        shift and go to state 135
    return                         shift and go to state 136
    continue                       shift and go to state 137
    break                          shift and go to state 138
    logical_expression             shift and go to state 139
    assignment                     shift and go to state 140
    vars_declaration               shift and go to state 141
    logical_or_expression          shift and go to state 39
    lvalue                         shift and go to state 149
    type                           shift and go to state 150
    type_array                     shift and go to state 8
    logical_and_expression         shift and go to state 41
    ident                          shift and go to state 35
    get_element                    shift and go to state 40
    equality_expression            shift and go to state 42
    relational_expression          shift and go to state 43
    additive_expression            shift and go to state 44
    multiplicative_expression      shift and go to state 45
    unary_expression               shift and go to state 48
    postfix_expression             shift and go to state 49
    group                          shift and go to state 51
    call                           shift and go to state 52
    number                         shift and go to state 54
    string                         shift and go to state 55
    bool_value                     shift and go to state 56

state 201

    (113) for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .

    RBRACE          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    LBRACE          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    SEMICOLON       reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    IF              reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    FOR             reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    WHILE           reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    DO              reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    RETURN          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    CONTINUE        reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    BREAK           reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    IDENT           reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    NOT             reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    SUB             reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    ADD             reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    LPAREN          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    NUMBER          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    STRING          reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    TRUE            reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    FALSE           reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)
    ELSE            reduce using rule 113 (for -> FOR LPAREN expression_list SEMICOLON for_condition SEMICOLON expression_list RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 3 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 12 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 13 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 18 resolved as shift
WARNING: shift/reduce conflict for ADD in state 44 resolved as shift
WARNING: shift/reduce conflict for SUB in state 44 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 87 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 92 resolved as shift
WARNING: shift/reduce conflict for ADD in state 105 resolved as shift
WARNING: shift/reduce conflict for SUB in state 105 resolved as shift
WARNING: shift/reduce conflict for ADD in state 106 resolved as shift
WARNING: shift/reduce conflict for SUB in state 106 resolved as shift
WARNING: shift/reduce conflict for ADD in state 107 resolved as shift
WARNING: shift/reduce conflict for SUB in state 107 resolved as shift
WARNING: shift/reduce conflict for ADD in state 108 resolved as shift
WARNING: shift/reduce conflict for SUB in state 108 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 130 resolved as shift
WARNING: shift/reduce conflict for NOT in state 146 resolved as shift
WARNING: shift/reduce conflict for SUB in state 146 resolved as shift
WARNING: shift/reduce conflict for ADD in state 146 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 146 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 146 resolved as shift
WARNING: shift/reduce conflict for STRING in state 146 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 146 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 146 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 146 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 155 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 187 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 199 resolved as shift
